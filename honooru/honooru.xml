<?xml version="1.0"?>
<doc>
    <assembly>
        <name>honooru</name>
    </assembly>
    <members>
        <member name="M:honooru.Code.AnsiParser.Parse(System.String)">
            <summary>
            Parses a subset of display attributes
            Set Display Attributes
            Set Attribute Mode [{attr1};...;{attrn}m
            Sets multiple display attribute settings. The following lists standard attributes that are getting parsed:
            1 Bright
            Foreground Colours
            30 Black
            31 Red
            32 Green
            33 Yellow
            34 Blue
            35 Magenta
            36 Cyan
            37 White
            Background Colours
            40 Black
            41 Red
            42 Green
            43 Yellow
            44 Blue
            45 Magenta
            46 Cyan
            47 White
            </summary>
        </member>
        <member name="F:honooru.Code.Constants.PostRating.GENERAL">
            <summary>
                this post is fine to view, and does not contain any issues with the content
            </summary>
        </member>
        <member name="F:honooru.Code.Constants.PostRating.UNSAFE">
            <summary>
                this post contains offensive
            </summary>
        </member>
        <member name="F:honooru.Code.Constants.PostRating.EXPLICIT">
            <summary>
                this is not good stuff
            </summary>
        </member>
        <member name="T:honooru.Code.Converters.DateTimeJsonConverter">
            <summary>
            Custom <c>DateTime</c> converter to avoid changing the format based on <see cref="P:System.DateTime.Kind"/>
            </summary>
            <remarks>
            The default <c>DateTime</c> converter uses <see cref="P:System.DateTime.Kind"/> to determine the format.
                If it's <see cref="F:System.DateTimeKind.Local"/>, it is send as UTC with the timezone offset
                If it's <see cref="F:System.DateTimeKind.Unspecified"/>, no 'Z' is added
                If it's <see cref="F:System.DateTimeKind.Utc"/>, it's formatted how this is
                
            Because all <c>DateTime</c>s are treated as UTC, regardless of the <see cref="P:System.DateTime.Kind"/> value,
                this default formatter fails to convert certain <c>DateTime</c>s to the format the frontend expects.
                
            This converter assumes all <see cref="T:System.DateTime"/>s passed are in UTC, and will always include the 'Z' denoting
                this date string is in UTC (Following the ISO 8601 standard)
            </remarks>
        </member>
        <member name="M:honooru.Code.DiscordInteractions.AppAccountSlashCommand.WhoAmICommand(DSharpPlus.SlashCommands.InteractionContext)">
            <summary>
                Slash command to get the current <see cref="T:honooru.Models.AppAccount"/>
            </summary>
            <param name="ctx">Provided context</param>
        </member>
        <member name="M:honooru.Code.DiscordInteractions.AppAccountSlashCommand.WhoIsCommand(DSharpPlus.SlashCommands.InteractionContext,DSharpPlus.Entities.DiscordUser)">
            <summary>
                Slash command to get the permission of a target user
            </summary>
            <param name="ctx">Provided context</param>
            <param name="user">Discord user to get the permissions of</param>
        </member>
        <member name="M:honooru.Code.DiscordInteractions.AppAccountSlashCommand.WhoIsContext(DSharpPlus.SlashCommands.ContextMenuContext)">
            <summary>
                Context menu command to get the account permissions of the target user
            </summary>
            <param name="ctx"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Code.DiscordInteractions.ExampleSlashCommands.ServerStatus(DSharpPlus.SlashCommands.InteractionContext,System.Int64)">
            <summary>
                Get some basic information about a server
            </summary>
            <param name="ctx">provided context</param>
            <param name="max">max value</param>
        </member>
        <member name="T:honooru.Code.DiscordInteractions.ServerStatusButtonCommands">
            <summary>
                Interactions for buttons on messages
            </summary>
        </member>
        <member name="M:honooru.Code.DiscordInteractions.ServerStatusButtonCommands.REFRESH_RANDOM(System.Int64)">
            <summary>
                Button to refresh the general world status in a message
            </summary>
            <param name="previousValue">value to not allow as the new random value</param>
        </member>
        <member name="M:honooru.Code.DiscordInteractions.ServerStatusButtonCommands.RefreshWorld(DSharpPlus.ButtonCommands.ButtonContext,System.Int64)">
            <summary>
                Refresh a message with updated world information
            </summary>
            <param name="ctx">Provided context</param>
            <param name="previousValue">what the new random value cannot be</param>
        </member>
        <member name="T:honooru.Code.DiscordInteractions.ServerStatusInteractions">
            <summary>
                Backing interactions used by both slash commands and button commands
            </summary>
        </member>
        <member name="M:honooru.Code.DiscordInteractions.ServerStatusInteractions.GeneralStatus(System.Int64)">
            <summary>
                example embed
            </summary>
            <param name="previousValue">ID of the world</param>
        </member>
        <member name="T:honooru.Code.DiscordInteractions.PermissionSlashCommand">
            <summary>
                Class to inherit from if executing a Discord slash command requires a specific account permission
            </summary>
        </member>
        <member name="M:honooru.Code.DiscordInteractions.PermissionSlashCommand._CheckPermission(DSharpPlus.SlashCommands.InteractionContext,System.String[])">
            <summary>
                Check if a Discord user performing a slash command has the correct account permission
            </summary>
            <param name="ctx">InteractionContext from the method</param>
            <param name="permissions">List of permissions that user can have. This is an OR operation</param>
            <returns>
                True if the user performing the command in <paramref name="ctx"/>
                has one of the permissions passed in <paramref name="permissions"/>,
                otherwise <c>false</c>, which will also respond to the command with an appropriate message
            </returns>
        </member>
        <member name="T:honooru.Code.DiscordInteractions.RequiredAccountPermissionAttribute">
            <summary>
                Attribute to require a user to have an account permission
            </summary>
        </member>
        <member name="T:honooru.Code.DiscordInteractions.RequiredAccountPermissionSlashAttribute">
            <summary>
                Attribute on slash commands to require an account permission
            </summary>
        </member>
        <member name="T:honooru.Code.DiscordInteractions.RequiredAppPermissionContextAttribute">
            <summary>
                Attribute on a context menu command to require an account permission
            </summary>
        </member>
        <member name="M:honooru.Code.DiscordInteractions.ServiceProviderExtensionMethods.AddAppDiscord(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
                Add interaction services that generate responses based on inputs
            </summary>
            <param name="services">extension instance</param>
        </member>
        <member name="T:honooru.Code.ExceptionHandlerMiddleware">
            <summary>
                middleware to handle uncaught exceptions and format them into the problems format
            </summary>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.ActivityExtensionMethods.AddExceptionEvent(System.Diagnostics.Activity,System.Exception)">
            <summary>
                Add an event to a span indicating an exception occured. This handles creating the event and tagging it correctly
            </summary>
            <param name="span">Extension instance</param>
            <param name="ex">Exception to tag the <see cref="T:System.Diagnostics.Activity"/> with</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.DiscordClientExtensionMethods.TryGetGuild(DSharpPlus.DiscordClient,System.UInt64)">
            <summary>
                Try to get a guild, catching a NotFoundException and instead returning null
            </summary>
            <param name="client">Extension instance</param>
            <param name="guildID">ID of the guild to get</param>
            <returns>
                The <see cref="T:DSharpPlus.Entities.DiscordGuild"/> with <see cref="P:DSharpPlus.Entities.SnowflakeObject.Id"/> of <paramref name="guildID"/>,
                or <c>null</c> if not found
            </returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.DiscordClientExtensionMethods.TryGetMember(DSharpPlus.Entities.DiscordGuild,System.UInt64)">
            <summary>
                Try to get a <see cref="T:DSharpPlus.Entities.DiscordMember"/> from a <see cref="T:DSharpPlus.Entities.DiscordGuild"/>,
                catching a <see cref="T:DSharpPlus.Exceptions.NotFoundException"/> and returning null instead
            </summary>
            <param name="guild">Extension instance</param>
            <param name="memberID">ID of the member to get</param>
            <returns>
                The <see cref="T:DSharpPlus.Entities.DiscordMember"/> with <see cref="P:DSharpPlus.Entities.SnowflakeObject.Id"/> of <paramref name="memberID"/>,
                or <c>null</c> if the member could not be found
            </returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.DiscordClientExtensionMethods.TryGetChannel(DSharpPlus.Entities.DiscordGuild,System.UInt64)">
            <summary>
                Try to get a <see cref="T:DSharpPlus.Entities.DiscordChannel"/> of a <see cref="T:DSharpPlus.Entities.DiscordGuild"/>
                returning <c>null</c> if it isn't found
            </summary>
            <param name="guild"></param>
            <param name="channelID"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.DiscordClientExtensionMethods.TryGetMessage(DSharpPlus.Entities.DiscordChannel,System.UInt64)">
            <summary>
                Try to get a message within a client, catching <see cref="T:DSharpPlus.Exceptions.NotFoundException"/> and returning null instead
            </summary>
            <param name="channel">Extension instance</param>
            <param name="msgID">ID of the message to load</param>
            <returns>
                A <see cref="T:DSharpPlus.Entities.DiscordMessage"/> with <see cref="P:DSharpPlus.Entities.SnowflakeObject.Id"/> of <paramref name="msgID"/>,
                or <c>null</c> if it does not exist
            </returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.DiscordMemberExtensionMethods.HasRole(DSharpPlus.Entities.DiscordMember,System.UInt64[])">
            <summary>
                Check if a <see cref="T:DSharpPlus.Entities.DiscordMember"/> has one of the roles provided in <paramref name="roleIDs"/>
            </summary>
            <param name="member">extension instance</param>
            <param name="roleIDs">List of role IDs</param>
            <returns>
                If <paramref name="member"/> has at least one <see cref="T:DSharpPlus.Entities.DiscordRole"/>
                with a <see cref="P:DSharpPlus.Entities.SnowflakeObject.Id"/> within <paramref name="roleIDs"/>
            </returns>
        </member>
        <member name="T:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods">
            <summary>
                helper extensions to make responses easier
            </summary>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.CreateImmediateText(DSharpPlus.SlashCommands.BaseContext,System.String,System.Boolean)">
            <summary>
                Create a <see cref="F:DSharpPlus.InteractionResponseType.ChannelMessageWithSource"/> response with a message
            </summary>
            <param name="ctx">Extension instance</param>
            <param name="message">Message to send</param>
            <param name="ephemeral">Will the response only be shown to the person who used the command?</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.CreateDeferred(DSharpPlus.SlashCommands.BaseContext,System.Boolean)">
            <summary>
                Create a deferred response that will show a thinking indicator
            </summary>
            <param name="ctx">Extension instance</param>
            <param name="ephemeral">Will the response only be shown to the person who used the command?</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.EditResponseEmbed(DSharpPlus.SlashCommands.BaseContext,DSharpPlus.Entities.DiscordEmbed)">
            <summary>
                Edit a response with an embed
            </summary>
            <param name="ctx">extension instance</param>
            <param name="embed">embed to edit into the response</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.EditResponseText(DSharpPlus.SlashCommands.BaseContext,System.String)">
            <summary>
                Edit a deferred response started with <see cref="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.CreateDeferred(DSharpPlus.SlashCommands.BaseContext,System.Boolean)"/>
                with a text message
            </summary>
            <param name="ctx">Extension instance</param>
            <param name="message">Message to send</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.CreateImmediateText(DSharpPlus.Entities.DiscordInteraction,System.String,System.Boolean)">
            <summary>
                Create an text response to an interaction and send it
            </summary>
            <param name="ctx">Extension instance</param>
            <param name="message">Message to be send</param>
            <param name="ephemeral">Will this message be dismissable?</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.CreateDeferred(DSharpPlus.Entities.DiscordInteraction,System.Boolean)">
            <summary>
                Create a deferred response that will show a thinking indicator
            </summary>
            <param name="ctx">Extension instance</param>
            <param name="ephemeral">Will this message be dismissable?</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.CreateComponentDeferred(DSharpPlus.Entities.DiscordInteraction,System.Boolean)">
            <summary>
                Create a deferred response to a component interaction
            </summary>
            <param name="ctx">extension instance</param>
            <param name="ephemeral">will this response be ephemeral?</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.CreateImmediateEmbed(DSharpPlus.Entities.DiscordInteraction,DSharpPlus.Entities.DiscordEmbedBuilder,System.Boolean)">
            <summary>
                Create an immediate response with an embed builder
            </summary>
            <param name="ctx">Extension instance</param>
            <param name="builder">Embed builder</param>
            <param name="ephemeral">Will this message be dismissable?</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.EditResponseEmbed(DSharpPlus.Entities.DiscordInteraction,DSharpPlus.Entities.DiscordEmbedBuilder)">
            <summary>
                Edit a deferred response started with <see cref="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.CreateDeferred(DSharpPlus.Entities.DiscordInteraction,System.Boolean)"/>
                with an embed response
            </summary>
            <param name="ctx">Extension instance</param>
            <param name="builder">Embed builder</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.EditResponseEmbed(DSharpPlus.Entities.DiscordInteraction,DSharpPlus.Entities.DiscordEmbed[])">
            <summary>
                Edit a response with a list of embeds
            </summary>
            <param name="ctx">extension instance</param>
            <param name="embeds">embeds to edit into the response</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.EditResponseEmbed(DSharpPlus.Entities.DiscordInteraction,System.Collections.Generic.IReadOnlyList{DSharpPlus.Entities.DiscordEmbed})">
            <summary>
                Edit a response with a list of embeds
            </summary>
            <param name="ctx">extension instance</param>
            <param name="embeds">embeds to edit into the response</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.EditResponseText(DSharpPlus.Entities.DiscordInteraction,System.String)">
            <summary>
                Edit a deferred response started with <see cref="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.CreateDeferred(DSharpPlus.Entities.DiscordInteraction,System.Boolean)"/>
                with a text message response
            </summary>
            <param name="ctx">Extension instance</param>
            <param name="message">Text message to be sent</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.InteractionContextDSharpExtensionMethods.EditResponseErrorEmbed(DSharpPlus.Entities.DiscordInteraction,System.String,System.String)">
            <summary>
                Edit a deferred response with an error message as an embed
            </summary>
            <param name="ctx">extension instance</param>
            <param name="error">description of the error, goes into the description of the embed</param>
            <param name="title">optional title, defaults to "Error"</param>
        </member>
        <member name="T:honooru.Code.ExtensionMethods.JsonElementExtensionMethods">
            <summary>
            Helper extension methods for getting types used frequently, or specific fields used a lot
            </summary>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.JsonElementExtensionMethods.GetValue``1(System.Text.Json.JsonElement,System.String)">
            <summary>
                From an object json, get the value of a field within the object
            </summary>
            <typeparam name="T">Type to get. Usually an unmanaged type</typeparam>
            <param name="elem">Extension instance</param>
            <param name="name">Case-sensitive name of field within <paramref name="elem"/></param>
            <returns>
                A nullable value of <typeparamref name="T"/>. If the field within <paramref name="elem"/> does not exist,
                or has a <c>null</c> value, then <c>null</c> will be returned
            </returns>
            <exception cref="T:System.InvalidOperationException">
                If <paramref name="elem"/> has a <see cref="P:System.Text.Json.JsonElement.ValueKind"/> of <see cref="F:System.Text.Json.JsonValueKind.Undefined"/>
            </exception>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.JsonElementExtensionMethods.GetRequiredString(System.Text.Json.JsonElement,System.String)">
            <summary>
                Get a string from a token. If there is no field in <paramref name="token"/> matching <paramref name="name"/>,
                or the field is a null value, a <see cref="T:System.ArgumentNullException"/> will be thrown
            </summary>
            <param name="token">Extension instance</param>
            <param name="name">Name of the field within <paramref name="token"/> to read from</param>
            <returns>
                A string 
            </returns>
            <exception cref="T:System.ArgumentNullException">
                If <paramref name="token"/> does not contain a field named <paramref name="name"/>,
                or the field with name <paramref name="name"/> has a null/undefined value
            </exception>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.JsonElementExtensionMethods.GetWorldID(System.Text.Json.JsonElement)">
            <summary>
                Get the 'world_id' field from a JsonElement, or -1 if it isn't in the token
            </summary>
            <param name="token">Extension instance</param>
            <returns>The Int16 in the field named 'world_id', or -1 if that field doesn't exist</returns>
        </member>
        <member name="T:honooru.Code.ExtensionMethods.JTokenExtensionMethods">
            <summary>
            Helper extension methods for getting types used frequently, or specific fields used a lot
            </summary>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.JTokenExtensionMethods.GetWorldID(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Get the 'world_id' field from a JToken, or -1 if it isn't in the token
            </summary>
            <param name="token">Extension instance</param>
            <returns>The Int16 in the field named 'world_id', or -1 if that field doesn't exist</returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.NpgsqlCommandExtensionMethod.AddParameter(Npgsql.NpgsqlCommand,System.String,System.Object)">
            <summary>
                Add a parameter to a <see cref="T:Npgsql.NpgsqlCommand"/>
            </summary>
            <remarks>
                Useful, as <see cref="M:Npgsql.NpgsqlParameterCollection.AddWithValue(System.String,System.Object)"/> doesn't
                allow nullable values for the value parameter. Null is allowed, but it's safer to pass
                <see cref="F:System.DBNull.Value"/>, which this extension method checks for and does
                
                Unsigned ints are turned into ints, as unsigned ints aren't supported
            </remarks>
            <param name="command">Extension instance</param>
            <param name="name">Name of the parameter</param>
            <param name="value">Value of the parameter</param>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.NpgsqlCommandExtensionMethod.Print(Npgsql.NpgsqlCommand)">
            <summary>
            Turn a command into text that's useful
            </summary>
            <param name="cmd"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.NpgsqlCommandExtensionMethod.ExecuteInt32(Npgsql.NpgsqlCommand,System.Threading.CancellationToken)">
            <summary>
                Execute a command as a scalar, converting the returned object to an Int32, then close the connection
            </summary>
            <param name="cmd">Command to execute as a scalar</param>
            <param name="cancel">Cancellation token</param>
            <returns>
                The result of executing <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync"/> parsed to an int
            </returns>
            <exception cref="T:System.NullReferenceException">
                Throw if the result from <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync"/> is null.
                SQL commands executed with this method must return a scalar
            </exception>
            <exception cref="T:System.InvalidCastException">
                Throw if the result from <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync"/> could
                not be parsed to a valid int
            </exception>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.NpgsqlCommandExtensionMethod.ExecuteInt64(Npgsql.NpgsqlCommand,System.Threading.CancellationToken)">
            <summary>
                Execute a command as a scalar, converting the returned object to an Int64, then close the connection
            </summary>
            <param name="cmd">Command to execute as a scalar</param>
            <param name="cancel">Cancellation token</param>
            <returns>
                The result of executing <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync"/> parsed to a long
            </returns>
            <exception cref="T:System.NullReferenceException">
                Throw if the result from <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync"/> is null.
                SQL commands executed with this method must return a scalar
            </exception>
            <exception cref="T:System.InvalidCastException">
                Throw if the result from <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync"/> could
                not be parsed to a valid long
            </exception>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.NpgsqlCommandExtensionMethod.ExecuteUInt64(Npgsql.NpgsqlCommand,System.Threading.CancellationToken)">
            <summary>
                Execute a command as a scalar, converting the returned object to an Int64, then close the connection
            </summary>
            <param name="cmd">Command to execute as a scalar</param>
            <param name="cancel">Cancellation token</param>
            <returns>
                The result of executing <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync"/> parsed to a long
            </returns>
            <exception cref="T:System.NullReferenceException">
                Throw if the result from <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync"/> is null.
                SQL commands executed with this method must return a scalar
            </exception>
            <exception cref="T:System.InvalidCastException">
                Throw if the result from <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync"/> could
                not be parsed to a valid long
            </exception>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.NpgsqlCommandExtensionMethod.ExecuteReadSingle``1(Npgsql.NpgsqlCommand,honooru.Services.Db.IDataReader{``0},System.Threading.CancellationToken)">
            <summary>
                Execute a single read from a command, using the reader to turn it into <typeparamref name="T"/>
            </summary>
            <typeparam name="T">What type will be returned</typeparam>
            <param name="cmd">Command to be executed</param>
            <param name="reader">Reader used to read the data</param>
            <param name="cancel">Cancellation token</param>
            <returns>
                A single read from <paramref name="reader"/> performed on <paramref name="cmd"/>.
                If there was no data to be read, <c>null</c> is instead returned
            </returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.NpgsqlCommandExtensionMethod.ExecuteReadList``1(Npgsql.NpgsqlCommand,honooru.Services.Db.IDataReader{``0},System.Threading.CancellationToken)">
            <summary>
                Execute a list read from a command, using <paramref name="reader"/> to turn it into <typeparamref name="T"/>
            </summary>
            <typeparam name="T">What type the generic list will be</typeparam>
            <param name="cmd">Extension instance</param>
            <param name="reader">Reader that can turn a row of data into <typeparamref name="T"/></param>
            <param name="cancel">Cancellation token</param>
            <returns>
                A list of all rows returned by executing <paramref name="cmd"/>,
                transformed into <typeparamref name="T"/> by <paramref name="reader"/>
            </returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.NpgsqlDataReaderExtensionMethods.GetNullableString(Npgsql.NpgsqlDataReader,System.String)">
            <summary>
            Get a string value from a column that may ben ull
            </summary>
            <param name="reader"></param>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.NpgsqlDataReaderExtensionMethods.GetUInt32(Npgsql.NpgsqlDataReader,System.String)">
            <summary>
            Get a <see cref="T:System.UInt32"/> from a column
            </summary>
            <param name="reader">Extension instance</param>
            <param name="field">Name of that field that has the <c>uint</c></param>
            <returns>The <c>uint</c> in the column, cast from an int32</returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.QueueExtensionMethods.DequeueOrDefault``1(System.Collections.Generic.Queue{``0})">
            <summary>
                deqeueue an element from the <see cref="T:System.Collections.Generic.Queue`1"/>,
                returning null if the queue is empty
            </summary>
            <typeparam name="T"></typeparam>
            <param name="queue"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.StackExtensionMethods.PopOrDefault``1(System.Collections.Generic.Stack{``0})">
            <summary>
                pop the top element off of the <see cref="T:System.Collections.Generic.Stack`1"/>,
                or returning null if the stack is empty
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stack"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.TaskExtentionMethods.TimeoutWithDefault``1(System.Threading.Tasks.Task{``0},System.TimeSpan,``0)">
            <summary>
                run a task, and if a delay of <paramref name="delay"/> passes with <paramref name="task"/>
                not completing, instead return <paramref name="fallback"/>
            </summary>
            <typeparam name="T">parameter type that <paramref name="task"/> will return</typeparam>
            <param name="task">extension instance</param>
            <param name="delay">how long to delay before returning <paramref name="fallback"/></param>
            <param name="fallback">fallback value returned if <paramref name="delay"/> of delay</param>
            <returns>
                 a task that will contain the result of <paramref name="task"/> if it completed
                 within the time span <paramref name="delay"/>, or <paramref name="fallback"/>
                 if it took longer than <paramref name="delay"/>
            </returns>
        </member>
        <member name="M:honooru.Code.ExtensionMethods.TaskExtentionMethods.TimeoutWithThrow``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>
                run a task, and if a delay of <paramref name="delay"/> passes with <paramref name="task"/>
                not completing, throw a <see cref="T:System.TimeoutException"/>
            </summary>
            <typeparam name="T">parameter type that <paramref name="task"/> will return</typeparam>
            <param name="task">extension instance</param>
            <param name="delay">how long to delay before throwing a timeout exception</param>
            <returns>
                 a task that will contain the result of <paramref name="task"/> if it completed
                 within the time span <paramref name="delay"/>,
                 or a <see cref="T:System.TimeoutException"/>
            </returns>
        </member>
        <member name="T:honooru.Code.PermissionNeededAttribute">
            <summary>
                Attribute to add to actions to require a user to have a <see cref="T:honooru.Models.AppAccount"/>,
                and that account has the necessary permissions
            </summary>
        </member>
        <member name="T:honooru.Code.SearchBotBlockAttribute">
            <summary>
                Attribute to prevent search engines (more specifically, user agents that match a search engine) from calling an action
            </summary>
        </member>
        <member name="T:honooru.Code.SearchBotBlockFilter">
            <summary>
                Implementation filter of the block
            </summary>
        </member>
        <member name="F:honooru.Code.Tracking.AppActivitySource.Root">
            <summary>
                Root activity source timing is done from
            </summary>
        </member>
        <member name="M:honooru.Controllers.Api.AppAccountApiController.WhoAmI">
            <summary>
                Get the current user who is making the API call
            </summary>
            <response code="200">
                The response will contain the <see cref="T:honooru.Models.AppAccount"/> of the user who made the API call
            </response>
            <response code="204">
                The user making the API call is either not signed in, or no has no account
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.AppAccountApiController.GetAll">
            <summary>
                Get all accounts
            </summary>
            <response code="200">
                A list of all <see cref="T:honooru.Models.AppAccount"/>s
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.AppAccountApiController.CreateAccount(System.String,System.UInt64)">
            <summary>
                Create a new account
            </summary>
            <param name="name"></param>
            <param name="discordID"></param>
            <response code="200">
                The <see cref="P:honooru.Models.AppAccount.ID"/> of the <see cref="T:honooru.Models.AppAccount"/> that was created using the parameters passed
            </response>
            <response code="400">
                One of the following validation errors occured:
                <ul>
                    <li><paramref name="name"/> was empty or whitespace</li>
                    <li><paramref name="discordID"/> was 0</li>
                </ul>
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.AppAccountApiController.DeactiviateAccount(System.Int64)">
            <summary>
                mark an account as inactive
            </summary>
            <param name="accountID">ID of the account to mark as inactive</param>
            <response code="200">
                the account was successfully marked as inactive
            </response>
            <response code="400">
                <paramref name="accountID"/> was 1, which is the system account, which is not allowed
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.Account.UserSettingApiController.GetByCurrentUser">
            <summary>
                get the <see cref="T:honooru.Models.App.UserSetting"/>s of the current user
            </summary>
            <response code="200">
                the response will contain a list of <see cref="T:honooru.Models.App.UserSetting"/> with
                <see cref="P:honooru.Models.App.UserSetting.AccountID"/> of the user making the request
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.Account.UserSettingApiController.GetOtherByAccountID(System.UInt64)">
            <summary>
                get the <see cref="T:honooru.Models.App.UserSetting"/>s of another user
            </summary>
            <param name="accountID">ID of the user to get the settings of</param>
            <response code="200">
                a list of <see cref="T:honooru.Models.App.UserSetting"/>s with <see cref="P:honooru.Models.App.UserSetting.AccountID"/> of <paramref name="accountID"/>
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.Account.UserSettingApiController.Update(System.String,System.String)">
            <summary>
                update a <see cref="T:honooru.Models.App.UserSetting"/> of the user making the request
            </summary>
            <param name="name">name of the <see cref="T:honooru.Models.App.UserSetting"/> to update, or one will be created if it does not exist</param>
            <param name="value">value of the <see cref="T:honooru.Models.App.UserSetting"/></param>
            <response code="200">
                the <see cref="T:honooru.Models.App.UserSetting"/> with <see cref="P:honooru.Models.App.UserSetting.AccountID"/> of the account making the request,
                and <see cref="P:honooru.Models.App.UserSetting.Name"/> of <paramref name="name"/>,
                had it's <see cref="P:honooru.Models.App.UserSetting.Value"/> updated to <paramref name="value"/>
            </response>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:honooru.Controllers.Api.AppGroupPermissionApiController.GetByGroupID(System.UInt64)">
            <summary>
                Get the permissions an account has
            </summary>
            <param name="groupID">ID of the group</param>
            <response code="200">
                The response will contain a list of permissions an account has
            </response>
            <response code="404">
                No <see cref="T:honooru.Models.AppAccount"/> with <see cref="P:honooru.Models.AppAccount.ID"/> of <paramref name="groupID"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.AppGroupPermissionApiController.RemoveByID(System.Int64)">
            <summary>
                Remove a permission from an account
            </summary>
            <param name="accPermID">ID of the <see cref="T:honooru.Models.AppGroupPermission"/> to remove</param>
            <response code="200">
                The <see cref="T:honooru.Models.AppGroupPermission"/> with <see cref="P:honooru.Models.AppGroupPermission.ID"/>
                of <paramref name="accPermID"/> was successfully deleted
            </response>
            <response code="404">
                No <see cref="T:honooru.Models.AppGroupPermission"/> with <see cref="P:honooru.Models.AppGroupPermission.ID"/>
                of <paramref name="accPermID"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.AppGroupPermissionApiController.AddPermission(System.UInt64,System.String)">
            <summary>
                Insert a new permission for a group
            </summary>
            <param name="groupID">ID of the group to add the permission to</param>
            <param name="permission">Permission to be added to the account</param>
            <response code="200">
                The reponse will contain the ID of the <see cref="T:honooru.Models.AppGroupPermission"/> that was just created
                using the parameters passed
            </response>
            <response code="400">
                The account already has a <see cref="T:honooru.Models.AppGroupPermission"/> for <paramref name="permission"/>
            </response>
            <response code="404">
                One of the following objects count not be found:
                <ul>
                    <li><see cref="T:honooru.Models.Internal.AppGroup"/> with <see cref="P:honooru.Models.Internal.AppGroup.ID"/> of <paramref name="groupID"/></li>
                    <li><see cref="T:honooru.Models.Internal.AppPermission"/> with <see cref="P:honooru.Models.Internal.AppPermission.ID"/> of <paramref name="permission"/></li>
                </ul>
            </response>
            <exception cref="T:System.SystemException"></exception>
        </member>
        <member name="M:honooru.Controllers.Api.AppPermissionApiController.GetAll">
            <summary>
                Get all permissions available to users
            </summary>
            <response code="200">
                A list of <see cref="T:honooru.Models.Internal.AppPermission"/>s
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.AdminApiController.RemakeAllThumbnails">
            <summary>
                submit all posts for thumbnail recreation
            </summary>
            <response code="200">
                all posts were submitted for thumbnail recreation. the recreation could still be going, there is
                no way to check the progress of the queue
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.AdminApiController.RemakeAllIqdbEntries">
            <summary>
                submit all posts to recreate IQDB hashes
            </summary>
            <response code="200">
                the request is complete. this response code has no bearing on the success of the IQDB entry recreation
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.DebugApiController.GetRequestIp">
            <summary>
                debug method to get the IP of the request
            </summary>
            <response code="200">
                a string representing the IP of the client making the request, or "missing?" if for some reason no IP could be found
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.HealthApiController.GetRealtimeHealth">
            <summary>
                Get an object that indicates how healthy the app is in various metrics
            </summary>
            <remarks>
                Feel free to hammer this endpoint as much as you'd like. The results are cached for 800ms, and it only takes like 2ms to
                get all the data, so hitting this endpoint is not a burden
            </remarks>
            <response code="200">
                The response will contain a <see cref="T:honooru.Models.Health.AppHealth"/> that represents the health of the app at the time of being called
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.MediaAssetApiController.GetByGuid(System.Guid)">
            <summary>
                get a <see cref="T:honooru.Models.App.MediaAsset"/> by its <see cref="P:honooru.Models.App.MediaAsset.Guid"/>
            </summary>
            <param name="guid">ID of the <see cref="T:honooru.Models.App.MediaAsset"/> to get</param>
            <response code="200">
                the response will contain the <see cref="T:honooru.Models.App.MediaAsset"/> with
                <see cref="P:honooru.Models.App.MediaAsset.Guid"/> of <paramref name="guid"/>
            </response>
            <response code="204">
                no <see cref="T:honooru.Models.App.MediaAsset"/> with <see cref="P:honooru.Models.App.MediaAsset.Guid"/> of <paramref name="guid"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.MediaAssetApiController.GetProcessing">
            <summary>
                get a list of <see cref="T:honooru.Models.App.MediaAsset"/>s that are currently, or are queued for, processing
            </summary>
            <response code="200">
                the response will contain a list of <see cref="T:honooru.Models.App.MediaAsset"/>
                with a <see cref="P:honooru.Models.App.MediaAsset.Status"/> of <see cref="F:honooru.Models.App.MediaAssetStatus.PROCESSING"/>
                or <see cref="F:honooru.Models.App.MediaAssetStatus.QUEUED"/>
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.MediaAssetApiController.GetReady">
            <summary>
                get a list of <see cref="T:honooru.Models.App.MediaAsset"/>s that are ready to be tagged
            </summary>
            <response code="200">
                the response will contain a list of <see cref="T:honooru.Models.App.MediaAsset"/>
                with a <see cref="P:honooru.Models.App.MediaAsset.Status"/> of <see cref="F:honooru.Models.App.MediaAssetStatus.DONE"/>
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.MediaAssetApiController.UploadUrl(System.String)">
            <summary>
                upload a file via a URL
            </summary>
            <param name="url">URL to upload</param>
            <response code="200">
                the response will contain the <see cref="T:honooru.Models.App.MediaAsset"/> that was uploaded.
                it may not be ready for viewing, check <see cref="P:honooru.Models.App.MediaAsset.Status"/> for that
            </response>
            <response code="400">
                one of the following validation errors occured:
                <ul>
                    <li>the URL supplied could not be used to pull the file from</li>
                </ul>
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.MediaAssetApiController.Upload">
            <summary>
                upload a new media asset
            </summary>
            <remarks>
                example cURL request to upload:
                <code>curl.exe -X POST -H "Content-Type: multipart/form-data" -F "data=@test.mkv" "https://localhost:6001/api/post/upload"</code>
            </remarks>
            <response code="200">
                the response will contain a <see cref="T:honooru.Models.App.MediaAsset"/> created for this file being uploaded
            </response>
            <response code="302">
                a <see cref="T:honooru.Models.Db.Post"/> with a <see cref="P:honooru.Models.Db.Post.MD5"/> of the uploaded file already exists.
                the "Location" header will have the url to get the post
            </response>
            <response code="400">
                one of the following errors took place:
                <ul>
                    <li>the ContentType header did not start with "multipart/" </li>
                    <li>the boundary of the content type was missing</li>
                    <li>no content disposition exists</li>
                    <li>the extension from the uploaded file is missing</li>
                    <li>the extension from the uploaded file is invalid</li>
                </ul>
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.MediaAssetApiController._HandleAsset(honooru.Models.App.MediaAsset,System.IO.Stream,System.String)">
            <summary>
                common code to handle asset stuff
            </summary>
            <param name="asset"></param>
            <param name="targetFile"></param>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Controllers.Api.MediaAssetApiController.RegenerateIqdbHash(System.Guid)">
            <summary>
                regenerate the <see cref="P:honooru.Models.App.MediaAsset.IqdbHash"/>
            </summary>
            <param name="assetID">ID of the <see cref="T:honooru.Models.App.MediaAsset"/> to regenerate the IQDB hash of</param>
            <response code="200">
                the <see cref="P:honooru.Models.App.MediaAsset.IqdbHash"/> field of the <see cref="T:honooru.Models.App.MediaAsset"/>
                with <see cref="P:honooru.Models.App.MediaAsset.Guid"/> of <paramref name="assetID"/> was successfully updated,
                and included in the returned response
            </response>
            <response code="404">
                no <see cref="T:honooru.Models.App.MediaAsset"/> with <see cref="P:honooru.Models.App.MediaAsset.Guid"/> of <paramref name="assetID"/> exists
            </response>
            <response code="500">
                the IQDB service is not currently available
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.MediaAssetApiController.Delete(System.Guid)">
            <summary>
                delete a media asset
            </summary>
            <param name="assetID">GUID of the media asset to delete</param>
            <response code="200">
                the <see cref="T:honooru.Models.App.MediaAsset"/> with <see cref="P:honooru.Models.App.MediaAsset.Guid"/> of <paramref name="assetID"/>
                was successfully deleted, and removed from the IQDB service
            </response>
            <response code="404">
                no <see cref="T:honooru.Models.App.MediaAsset"/> with <see cref="P:honooru.Models.App.MediaAsset.Guid"/> of <paramref name="assetID"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.PostApiController.GetByID(System.UInt64)">
            <summary>
                get a <see cref="T:honooru.Models.Db.Post"/> by its <see cref="P:honooru.Models.Db.Post.ID"/>
            </summary>
            <param name="postID">ID of the <see cref="T:honooru.Models.Db.Post"/> to get</param>
            <response code="200">
                the response will contain the <see cref="T:honooru.Models.Db.Post"/> with <see cref="P:honooru.Models.Db.Post.ID"/>
                of <paramref name="postID"/>
            </response>
            <response code="204">
                no <see cref="T:honooru.Models.Db.Post"/> with <see cref="P:honooru.Models.Db.Post.ID"/> of <paramref name="postID"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.PostApiController.Search(System.String,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
                search for posts
            </summary>
            <param name="q">input search query</param>
            <param name="offset">offset into the search</param>
            <param name="limit">how many search results to return, max 500</param>
            <param name="includeTags">if <see cref="P:honooru.Models.Api.SearchResults.Tags"/> will be populated or not</param>
            <response code="200">
                the response will contain a <see cref="T:honooru.Models.Api.SearchResults"/> for the search performed
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.PostApiController.SearchByIqdbHash(System.String)">
            <summary>
                get similar images to the input IQDB hash
            </summary>
            <param name="iqdb">IQDB hash</param>
            <response code="200">
                the response will contain a list of <see cref="T:honooru.Models.App.Iqdb.IqdbQueryResult"/>s
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.PostApiController.Create(System.Guid,System.String,System.String,System.String,System.String,System.String)">
            <summary>
                create a new <see cref="T:honooru.Models.Db.Post"/> from a <see cref="T:honooru.Models.App.MediaAsset"/> that is ready to be used
            </summary>
            <remarks>
                if any <see cref="T:honooru.Models.App.Tag"/>s from <paramref name="tags"/> do not exist, then they are created.
                tags are space separated, and can contain a colon before the tag to change what <see cref="T:honooru.Models.App.TagType"/>
                the tag has, for both inserting and updating.
                <br/>
                <br/>
                examples:<br/>
                    <code>
            player:varunda base:indar_excavation_site montage youtube 
                    </code>
                    will create each tag if needed, and will set the type of 'varunda' to player,
                    and the type of indar_excavation_site to base, if the type is already set.
                    the types of montage and youtube will not be changed, or if the tags do not exist, 
                    will be set to general
            </remarks>
            <param name="assetID">The <see cref="P:honooru.Models.App.MediaAsset.Guid"/> of the <see cref="T:honooru.Models.App.MediaAsset"/> to use</param>
            <param name="tags">a string containing all the <see cref="T:honooru.Models.App.Tag"/>s that will be added to this post</param>
            <param name="rating">what the <see cref="P:honooru.Models.Db.Post.Rating"/> will be. valid values are: 'g', 'u' and 'e' (or any string that starts with those)</param>
            <param name="title">optional <see cref="P:honooru.Models.Db.Post.Title"/></param>
            <param name="description">optional <see cref="P:honooru.Models.Db.Post.Description"/></param>
            <param name="source">where the <see cref="T:honooru.Models.Db.Post"/> comes from</param>
            
            <response code="200">
                the response will contain the newly created <see cref="T:honooru.Models.Db.Post"/> using
                the parameters passed
            </response>
            
            <response code="400">
                one of the following validation errors occured:
                <ul>
                    <li>
                        an invalid <paramref name="rating"/> was passed.
                        valid values are: 'g', 'u', and 'e' (or any string that starts with those letters)
                    </li>
                    <li>
                        the <see cref="T:honooru.Models.App.MediaAsset"/> with <see cref="P:honooru.Models.App.MediaAsset.Guid"/> of <paramref name="assetID"/>
                        was not fully processed (according to <see cref="P:honooru.Models.App.MediaAsset.Status"/>, which is was not <see cref="F:honooru.Models.App.MediaAssetStatus.DONE"/>)
                    </li>
                    <li>
                        one of the space deliminated tags from <paramref name="tags"/> was invalid.
                        a tag can be invalid if one of the following conditions is met:
                        <ul>
                            <li>the tag contained more than one ':' (which are used to change the <see cref="T:honooru.Models.App.TagType"/> of a tag)</li>
                            <li>the tag contained invalid characters</li>
                            <li>when creating a new tag, and a <see cref="T:honooru.Models.App.TagType"/> is specified by using a ':', the <see cref="T:honooru.Models.App.TagType"/> could not be found</li>
                        </ul>
                    </li>
                </ul>
            </response>
            
            <response code="404">
                no <see cref="T:honooru.Models.App.MediaAsset"/> with <see cref="P:honooru.Models.App.MediaAsset.Guid"/> of <paramref name="assetID"/> exists
            </response>
            
        </member>
        <member name="M:honooru.Controllers.Api.PostApiController.Update(System.UInt64,System.String,System.String,System.String,System.String,System.String)">
            <summary>
                update an existing <see cref="T:honooru.Models.Db.Post"/> with new information
            </summary>
            <param name="postID">ID of the <see cref="T:honooru.Models.Db.Post"/> to update</param>
            <param name="tags">optional, leave null to not change. what tags to update the post with</param>
            <param name="rating">optional, leave null to not chagne. what rating to update the post with</param>
            <param name="title">optional, leave null to not change. what title to update the post with</param>
            <param name="description">optional, leave null to not change. what description to update the post with</param>
            <param name="source">optional, leave null to not change. what source to update the post with</param>
            <exception cref="T:System.Exception"></exception>
            <response code="200">
                the <see cref="T:honooru.Models.Db.Post"/> with <see cref="P:honooru.Models.Db.Post.ID"/> of <paramref name="postID"/> was successfully
                updated with all the non-null parameters. any parameter left <c>null</c> will result in that
                field not being updated
            </response>
            <response code="400">
                one of the following validation errors occurred:
                <ul>
                    <li><paramref name="rating"/> was not a valid valid</li>
                </ul>
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.PostApiController.RemakeThumbnail(System.UInt64)">
            <summary>
                enter a <see cref="T:honooru.Models.Db.Post"/> into the thumbnail creation queue for a forced-remake
            </summary>
            <param name="postID">ID of the <see cref="T:honooru.Models.Db.Post"/> to update</param>
            <response code="200">
                the <see cref="T:honooru.Models.Db.Post"/> with <see cref="P:honooru.Models.Db.Post.ID"/> of <paramref name="postID"/>
                successfully had it's thumbnail queued for recreation.
                NOTE: this DOES NOT MEAN the thumbnail was recreated, just that is was queued for recreation
            </response>
            <response code="404">
                no <see cref="T:honooru.Models.Db.Post"/> with <see cref="P:honooru.Models.Db.Post.ID"/> of <paramref name="postID"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.PostApiController.Delete(System.UInt64)">
            <summary>
                mark a <see cref="T:honooru.Models.Db.Post"/> as deleted, which does not remove the file itself.
                does not remove the IQDB entry either
            </summary>
            <param name="postID">ID of the <see cref="T:honooru.Models.Db.Post"/> to delete</param>
            <response code="200">
                the <see cref="T:honooru.Models.Db.Post"/> with <see cref="P:honooru.Models.Db.Post.ID"/> of <paramref name="postID"/>
                was successfully marked as deleted
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.PostApiController.Restore(System.UInt64)">
            <summary>
                restore a deleted post
            </summary>
            <param name="postID">ID of the <see cref="T:honooru.Models.Db.Post"/> to restore</param>
            <response code="200">
                the <see cref="T:honooru.Models.Db.Post"/> with <see cref="P:honooru.Models.Db.Post.ID"/> of <paramref name="postID"/>
                successfully had its <see cref="P:honooru.Models.Db.Post.Status"/> updated to <see cref="F:honooru.Models.Db.PostStatus.OK"/>
            </response>
            <response code="400">
                the <see cref="T:honooru.Models.Db.Post"/> with <see cref="P:honooru.Models.Db.Post.ID"/> of <paramref name="postID"/>
                does not have a <see cref="P:honooru.Models.Db.Post.Status"/> of <see cref="F:honooru.Models.Db.PostStatus.DELETED"/>.
                only deleted posts can be restored
            </response>
            <response code="404">
                no <see cref="T:honooru.Models.Db.Post"/> with <see cref="P:honooru.Models.Db.Post.ID"/> of <paramref name="postID"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.PostApiController.Erase(System.UInt64)">
            <summary>
                completely erase a <see cref="T:honooru.Models.Db.Post"/>, deleting the IQDB entries and all files with it
            </summary>
            <param name="postID">ID of the post to erase</param>
            <returns></returns>
        </member>
        <member name="M:honooru.Controllers.Api.TagAliasApiController.GetByTagID(System.UInt64)">
            <summary>
                get the <see cref="T:honooru.Models.App.TagAlias"/>es of a specific <see cref="T:honooru.Models.App.Tag"/>
            </summary>
            <param name="tagID">ID of the <see cref="T:honooru.Models.App.Tag"/> to get the aliases of</param>
            <response code="200">
                the response will contain a list of <see cref="T:honooru.Models.App.TagAlias"/> with <see cref="P:honooru.Models.App.TagAlias.TagID"/>
                of <paramref name="tagID"/>
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.TagApiController.GetByID(System.UInt64)">
            <summary>
                get the basic <see cref="T:honooru.Models.App.Tag"/> information by ID
            </summary>
            <param name="tagID">ID of the <see cref="T:honooru.Models.App.Tag"/> to get</param>
            <response code="200">
                the <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="tagID"/>
            </response>
            <response code="204">
                no <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="tagID"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.TagApiController.GetExtenedByID(System.UInt64)">
            <summary>
                get the <see cref="T:honooru.Models.Api.ExtendedTag"/> information about a tag
            </summary>
            <param name="tagID">ID of the <see cref="T:honooru.Models.App.Tag"/> to get the <see cref="T:honooru.Models.Api.ExtendedTag"/> of</param>
            <response code="200">
                the <see cref="T:honooru.Models.Api.ExtendedTag"/> that corresponds to the <see cref="T:honooru.Models.App.Tag"/>
                with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="tagID"/>
            </response>
            <response code="204">
                no <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="tagID"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.TagApiController.GetByName(System.String)">
            <summary>
                get the <see cref="T:honooru.Models.Api.ExtendedTag"/> of the the <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.Name"/> of <paramref name="name"/>
            </summary>
            <param name="name">name of the <see cref="T:honooru.Models.App.Tag"/> (case does not matter)</param>
            <response code="200">
                the <see cref="T:honooru.Models.Api.ExtendedTag"/> for the <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.Name"/> of <paramref name="name"/>
            </response>
            <response code="204">
                no <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.Name"/> of <paramref name="name"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.TagApiController.Search(System.String,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean})">
            <summary>
                search for all tags based on a name. this performs a string distance search as well,
                so tags that are similar to the input are returned as well. see https://en.wikipedia.org/wiki/Levenshtein_distance for more.
            </summary>
            <param name="name">name of the tags to search for. required</param>
            <param name="limit">sets the maximum of how many tags are returned in the search results. defaults to 20</param>
            <param name="sortBy">
                how to sort the returned results. valid values are: "uses", "name".
                defaults to "uses", which uses <see cref="P:honooru.Models.Api.ExtendedTag.Uses"/>
            </param>
            <param name="sortAscending">if the sorted results will be in ascending (0 to 9) order or descending (9 to 0). defaults to false</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:honooru.Controllers.Api.TagApiController.Create(System.String,System.UInt64)">
            <summary>
                create a new <see cref="T:honooru.Models.App.Tag"/>
            </summary>
            <param name="name">name of the tag to use</param>
            <param name="typeID">ID of the <see cref="T:honooru.Models.App.TagType"/></param>
            <response code="200">
                the response contains the <see cref="T:honooru.Models.App.Tag"/> that was newly created,
                with <see cref="P:honooru.Models.App.Tag.ID"/> updated
            </response>
            <response code="400">
                one of the following validation errors occured:
                <ul>
                    <li><paramref name="name"/> is not valid for a tag name. the response will contain a string explaining why</li>
                    <li>a <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.Name"/> of <paramref name="name"/> already exists</li>
                </ul>
            </response>
            <response code="404">
                no <see cref="T:honooru.Models.App.TagType"/> with <see cref="P:honooru.Models.App.TagType.ID"/> of <paramref name="typeID"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.TagApiController.Update(System.UInt64,honooru.Models.Api.ExtendedTag)">
            <summary>
                update an existing tag with new info
            </summary>
            <param name="tagID"></param>
            <param name="tag"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Controllers.Api.TagApiController.RecountTagUsage(System.UInt64)">
            <summary>
                submit a tag for recount
            </summary>
            <param name="tagID">ID of the tag to recount</param>
            <response code="200">
                the <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="tagID"/>
                was successfully queued for a usage recount. this does not mean that the recount
                is complete
            </response>
            <response code="404">
                no <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="tagID"/> exists
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.TagImplicationApiController.Create(System.UInt64,System.UInt64)">
            <summary>
                create a new <see cref="T:honooru.Models.App.TagImplication"/>
            </summary>
            <param name="sourceTagID">
                ID of the <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="sourceTagID"/> that when applied to a post,
                will also add the <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="targetTagID"/>
            </param>
            <param name="targetTagID">
                when the <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="sourceTagID"/> is applied to a post,
                then this <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="targetTagID"/> is also added
            </param>
            <response code="200">
                a new <see cref="T:honooru.Models.App.TagImplication"/> was successfully created
            </response>
            <response code="400">
                one of the following validation errors occured:
                <ul>
                    <li><paramref name="sourceTagID"/> equals <paramref name="targetTagID"/></li>
                    <li>
                        there is already an implication with <see cref="P:honooru.Models.App.TagImplication.TagA"/> of <paramref name="sourceTagID"/>,
                        and <see cref="P:honooru.Models.App.TagImplication.TagB"/> of <paramref name="targetTagID"/>
                    </li>
                    <li>
                        there is already an implication with <see cref="P:honooru.Models.App.TagImplication.TagA"/> of <paramref name="targetTagID"/>,
                        and <see cref="P:honooru.Models.App.TagImplication.TagB"/> of <paramref name="sourceTagID"/>, which would create a loop
                    </li>
                </ul>
            </response>
            <response code="404">
                either the <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="sourceTagID"/> or <paramref name="targetTagID"/>
                does not exist
            </response>
        </member>
        <member name="M:honooru.Controllers.Api.TestErrorApiController.DbTimeout">
            <summary>
                throw an exception due to a DB timeout
            </summary>
            <response code="500">
                always
            </response>
        </member>
        <member name="T:honooru.Models.ApiResponse">
            <summary>
                Represents the base object all responses will follow
            </summary>
        </member>
        <member name="P:honooru.Models.ApiResponse.Status">
            <summary>
                Status code of the result
            </summary>
        </member>
        <member name="P:honooru.Models.ApiResponse.Data">
            <summary>
                Data of the response
            </summary>
        </member>
        <member name="T:honooru.Models.ApiResponse`1">
            <summary>
                Parameterized base response to an API request
            </summary>
            <typeparam name="T">Type to expect <see cref="P:honooru.Models.ApiResponse`1.Data"/> to be. However, this is not enforced</typeparam>
        </member>
        <member name="P:honooru.Models.ApiResponse`1.Status">
            <summary>
                Status code of the result
            </summary>
        </member>
        <member name="P:honooru.Models.ApiResponse`1.Data">
            <summary>
                Data of the response
            </summary>
        </member>
        <member name="T:honooru.Models.ApiResponseExecutor">
            <summary>
                <see cref="T:Microsoft.AspNetCore.Mvc.Infrastructure.IActionResultExecutor`1"/> that is executed when an <see cref="T:honooru.Models.ApiResponse"/> is
                returned from a controller
            </summary>
        </member>
        <member name="P:honooru.Models.Api.ServiceQueueCount.QueueName">
            <summary>
                Name of the queue
            </summary>
        </member>
        <member name="P:honooru.Models.Api.ServiceQueueCount.Count">
            <summary>
                How many items are currently in this queue
            </summary>
        </member>
        <member name="P:honooru.Models.Api.ServiceQueueCount.Processed">
            <summary>
                How many items have been removed from this queue
            </summary>
        </member>
        <member name="P:honooru.Models.Api.ServiceQueueCount.Average">
            <summary>
                The average time to process recent items in milliseconds
            </summary>
        </member>
        <member name="P:honooru.Models.Api.ServiceQueueCount.Min">
            <summary>
                The min time to process recent items in milliseconds
            </summary>
        </member>
        <member name="P:honooru.Models.Api.ServiceQueueCount.Median">
            <summary>
                The median time to process recent items in milliseconds
            </summary>
        </member>
        <member name="P:honooru.Models.Api.ServiceQueueCount.Max">
            <summary>
                The max time to process recent items in milliseconds
            </summary>
        </member>
        <member name="T:honooru.Models.Api.UploadStepProgress">
            <summary>
                represents the state of a single <see cref="T:honooru.Models.App.MediaUploadStep.IUploadStep"/>
            </summary>
        </member>
        <member name="P:honooru.Models.Api.UploadStepProgress.Name">
            <summary>
                name of the <see cref="T:honooru.Models.App.MediaUploadStep.IUploadStep"/>
            </summary>
        </member>
        <member name="P:honooru.Models.Api.UploadStepProgress.Order">
            <summary>
                in what order this <see cref="T:honooru.Models.App.MediaUploadStep.IUploadStep"/> will be performed
            </summary>
        </member>
        <member name="P:honooru.Models.Api.UploadStepProgress.Percent">
            <summary>
                what percent of this step is completed
            </summary>
        </member>
        <member name="P:honooru.Models.Api.UploadStepProgress.Finished">
            <summary>
                if this step is done or not
            </summary>
        </member>
        <member name="T:honooru.Models.Api.UploadStepEntry">
            <summary>
                represents the progress of a single <see cref="T:honooru.Models.App.MediaUploadStep.UploadSteps"/>
            </summary>
        </member>
        <member name="P:honooru.Models.Api.UploadStepEntry.Current">
            <summary>
                what step is currently being processed
            </summary>
        </member>
        <member name="P:honooru.Models.Api.UploadStepEntry.Progress">
            <summary>
                the progress on each step
            </summary>
        </member>
        <member name="P:honooru.Models.App.Iqdb.IqdbQueryResult.PostID">
            <summary>
                this post ID is the MD5 used to store the data in IQDB
            </summary>
        </member>
        <member name="P:honooru.Models.App.Iqdb.IqdbQueryResult.MD5">
            <summary>
                a lotta time this is the same as <see cref="P:honooru.Models.App.Iqdb.IqdbQueryResult.PostID"/>, but for videos, <see cref="P:honooru.Models.App.Iqdb.IqdbQueryResult.PostID"/> has -frame-#
                appended to <see cref="P:honooru.Models.App.Iqdb.IqdbQueryResult.PostID"/>, so this field only has the MD5 of the resources
            </summary>
        </member>
        <member name="P:honooru.Models.App.Iqdb.IqdbQueryResult.Score">
            <summary>
                score from -100 to 100 that indicates how closely this IQDB entry matches the input hash
            </summary>
        </member>
        <member name="P:honooru.Models.App.Iqdb.IqdbQueryResult.Hash">
            <summary>
                hash of the IQDB entry
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.Guid">
            <summary>
                temp guid the file is saved under
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.PostID">
            <summary>
                if this <see cref="T:honooru.Models.App.MediaAsset"/> uploaded exists as a post already, this is the ID of that post
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.MD5">
            <summary>
                md5 hash of the media asset
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.Status">
            <summary>
                status of the media asset
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.FileName">
            <summary>
                original file name
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.FileExtension">
            <summary>
                where this file is. does not include a leading period
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.Timestamp">
            <summary>
                when this asset was uploaded
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.FileSizeBytes">
            <summary>
                how many bytes long this fill is. not sure if a negative value is possible.
                using a <see cref="T:System.Int64"/> gives us files over 4GB (which is what an int would limit us to)
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.Source">
            <summary>
                where this media asset came from
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.AdditionalTags">
            <summary>
                additional tags that are added during parsing
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.Title">
            <summary>
                if set, used as the <see cref="P:honooru.Models.Db.Post.Title"/> when the asset is turned into a post
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.Description">
            <summary>
                if set, used as the <see cref="P:honooru.Models.Db.Post.Description"/> when the asset is turned into a post
            </summary>
        </member>
        <member name="P:honooru.Models.App.MediaAsset.IqdbHash">
            <summary>
                hash of the <see cref="T:honooru.Models.App.IqdbEntry"/> this media asset has. Is null until it is set
            </summary>
        </member>
        <member name="F:honooru.Models.App.MediaAssetStatus.DEFAULT">
            <summary>
                this media asset is in the default state and has not been processed yet
            </summary>
        </member>
        <member name="F:honooru.Models.App.MediaAssetStatus.QUEUED">
            <summary>
                this media asset has been queued for processing
            </summary>
        </member>
        <member name="F:honooru.Models.App.MediaAssetStatus.PROCESSING">
            <summary>
                this media asset is currently being processed
            </summary>
        </member>
        <member name="F:honooru.Models.App.MediaAssetStatus.DONE">
            <summary>
                this media asset is done and ready for tagging to become a post
            </summary>
        </member>
        <member name="F:honooru.Models.App.MediaAssetStatus.EXTRACTING">
            <summary>
                this media asset is being pulled from a URL
            </summary>
        </member>
        <member name="M:honooru.Models.App.MediaUploadStep.IUploadStepWorker`2.Run(`0,System.Action{System.Decimal},System.Threading.CancellationToken)">
            <summary>
                run the worker with the parameters needed
            </summary>
            <param name="order">what <see cref="T:honooru.Models.App.MediaUploadStep.IUploadStep"/> to work on</param>
            <param name="updateProgress">useful for long running tasks (such as reencoding), use this callback to update the progress of the step</param>
            <param name="cancel">cancellation token</param>
            <returns>
                true if the next <see cref="T:honooru.Models.App.MediaUploadStep.IUploadStep"/> is to be ran or not
            </returns>
        </member>
        <member name="P:honooru.Models.App.Tag.ID">
            <summary>
                unique ID
            </summary>
        </member>
        <member name="P:honooru.Models.App.Tag.Name">
            <summary>
                name of this tag. must be unique
            </summary>
        </member>
        <member name="P:honooru.Models.App.Tag.TypeID">
            <summary>
                ID of the <see cref="T:honooru.Models.App.TagType"/> this tag is for
            </summary>
        </member>
        <member name="P:honooru.Models.App.Tag.Timestamp">
            <summary>
                when this <see cref="T:honooru.Models.App.Tag"/> was created
            </summary>
        </member>
        <member name="P:honooru.Models.App.TagAlias.Alias">
            <summary>
                unique alias that maps to another tag
            </summary>
        </member>
        <member name="P:honooru.Models.App.TagAlias.TagID">
            <summary>
                id of the <see cref="T:honooru.Models.App.Tag"/> this alias is for
            </summary>
        </member>
        <member name="T:honooru.Models.App.TagImplication">
            <summary>
                an implication between two tags. when a post has the <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <see cref="P:honooru.Models.App.TagImplication.TagA"/>,
                then it will also have the <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <see cref="P:honooru.Models.App.TagImplication.TagB"/>
            </summary>
        </member>
        <member name="P:honooru.Models.App.TagNameValidationResult.Input">
            <summary>
                input name for validation
            </summary>
        </member>
        <member name="P:honooru.Models.App.TagNameValidationResult.Reason">
            <summary>
                if <see cref="P:honooru.Models.App.TagNameValidationResult.Valid"/> is <c>false</c>, why <see cref="P:honooru.Models.App.TagNameValidationResult.Input"/> is not valid
            </summary>
        </member>
        <member name="P:honooru.Models.App.TagNameValidationResult.Valid">
            <summary>
                if <see cref="P:honooru.Models.App.TagNameValidationResult.Input"/> is a valid tag name or not
            </summary>
        </member>
        <member name="P:honooru.Models.App.TagType.ID">
            <summary>
                unique ID
            </summary>
        </member>
        <member name="P:honooru.Models.App.TagType.Name">
            <summary>
                name of the tag type
            </summary>
        </member>
        <member name="P:honooru.Models.App.TagType.HexColor">
            <summary>
                hex color, does not include a leading #
            </summary>
        </member>
        <member name="P:honooru.Models.App.TagType.Alias">
            <summary>
                alias of the tag type. for example, if the name is general, the alias of gen: could be used
            </summary>
        </member>
        <member name="P:honooru.Models.App.TagType.Order">
            <summary>
                order to display tags within this type. smaller numbers mean highest in order (0 is first)
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.ID">
            <summary>
                unique ID of the post
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.PosterUserID">
            <summary>
                ID of the <see cref="T:honooru.Models.AppAccount"/> that posted this media
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.Timestamp">
            <summary>
                when this post was created
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.Title">
            <summary>
                an optional title
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.Description">
            <summary>
                an optional description
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.LastEditorUserID">
            <summary>
                the ID of the last <see cref="T:honooru.Models.AppAccount"/> to edit this post
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.LastEdited">
            <summary>
                when this post was last edited
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.MD5">
            <summary>
                MD5 hash of the file
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.Rating">
            <summary>
                what this post is rated as
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.FileName">
            <summary>
                original name of the file uploaded
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.Source">
            <summary>
                where this post comes from
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.FileExtension">
            <summary>
                file extension, WITH a leading .
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.IqdbHash">
            <summary>
                hash from the IQDB service
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.FileSizeBytes">
            <summary>
                how many bytes. not sure why c# has file size signed
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.DurationSeconds">
            <summary>
                how many seconds long this piece of media is. is set to 0 for images
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.Height">
            <summary>
                height of the post
            </summary>
        </member>
        <member name="P:honooru.Models.Db.Post.Width">
            <summary>
                width of the post
            </summary>
        </member>
        <member name="T:honooru.Models.Db.ExpEvent">
            <summary>
                When a Discord user would like to get notifications about a session ending, they will have one of these
            </summary>
        </member>
        <member name="P:honooru.Models.Db.ExpEvent.ID">
            <summary>
                Unique ID of the subscription
            </summary>
        </member>
        <member name="P:honooru.Models.Db.ExpEvent.DiscordID">
            <summary>
                What Discord ID created the subscription
            </summary>
        </member>
        <member name="P:honooru.Models.Db.ExpEvent.CharacterID">
            <summary>
                What character ID is the subscription for
            </summary>
        </member>
        <member name="P:honooru.Models.Db.ExpEvent.Timestamp">
            <summary>
                Timestamp of when this subscription was created
            </summary>
        </member>
        <member name="P:honooru.Models.DiscordOptions.Enabled">
            <summary>
                If Discord features are enabled or not
            </summary>
        </member>
        <member name="P:honooru.Models.DiscordOptions.ClientId">
            <summary>
                Client key
            </summary>
        </member>
        <member name="P:honooru.Models.DiscordOptions.ClientSecret">
            <summary>
                client secret
            </summary>
        </member>
        <member name="P:honooru.Models.DiscordOptions.RegisterGlobalCommands">
            <summary>
                Will the global commands be registered globally? Or just in the test server
            </summary>
        </member>
        <member name="P:honooru.Models.InstanceOptions.Host">
            <summary>
                Root domain of the host. Do not include https://. For example: localhost:6001
            </summary>
        </member>
        <member name="P:honooru.Models.Config.StorageOptions.RootDirectory">
            <summary>
                where all the files will be stored. can be absolute or relative
            </summary>
        </member>
        <member name="T:honooru.Models.Discord.AppDiscordMessage">
            <summary>
                Wrapper around whatever Discord library being used
            </summary>
        </member>
        <member name="M:honooru.Models.Discord.AppDiscordMessage.#ctor">
            <summary>
                nullary ctor
            </summary>
        </member>
        <member name="M:honooru.Models.Discord.AppDiscordMessage.#ctor(honooru.Models.Discord.AppDiscordMessage)">
            <summary>
                copy ctor
            </summary>
            <param name="other"></param>
        </member>
        <member name="P:honooru.Models.Discord.AppDiscordMessage.Message">
            <summary>
                Message to be sent. If you want to send an embedded message instead, populate <see cref="P:honooru.Models.Discord.AppDiscordMessage.Embeds"/>
            </summary>
        </member>
        <member name="P:honooru.Models.Discord.AppDiscordMessage.Embeds">
            <summary>
                Any embeds to use in the message. Leave empty to instead send <see cref="P:honooru.Models.Discord.AppDiscordMessage.Message"/> as plain text
            </summary>
        </member>
        <member name="P:honooru.Models.Discord.AppDiscordMessage.Mentions">
            <summary>
                Get the mentions this message contains
            </summary>
        </member>
        <member name="P:honooru.Models.Discord.AppDiscordMessage.Type">
            <summary>
                Get the <see cref="T:honooru.Models.Discord.AppDiscordMessage.TargetType"/> of this message
            </summary>
        </member>
        <member name="T:honooru.Models.Health.AppHealth">
            <summary>
                Information about the health of the running app
            </summary>
        </member>
        <member name="P:honooru.Models.Health.AppHealth.Queues">
            <summary>
                Information about the hosted queues in the running app
            </summary>
        </member>
        <member name="P:honooru.Models.Health.AppHealth.Timestamp">
            <summary>
                When this data was created
            </summary>
        </member>
        <member name="T:honooru.Models.ServiceHealthEntry">
            <summary>
                Represents meta information about a long running service 
            </summary>
        </member>
        <member name="P:honooru.Models.ServiceHealthEntry.Name">
            <summary>
                Name of the service this entry is for
            </summary>
        </member>
        <member name="P:honooru.Models.ServiceHealthEntry.LastRan">
            <summary>
                When this service was last ran
            </summary>
        </member>
        <member name="P:honooru.Models.ServiceHealthEntry.RunDuration">
            <summary>
                How many milliseconds it took for the service to be ran last time
            </summary>
        </member>
        <member name="P:honooru.Models.ServiceHealthEntry.Enabled">
            <summary>
                Is this service currently enabled and running? Only certain hosted services respect this
            </summary>
        </member>
        <member name="P:honooru.Models.ServiceHealthEntry.Message">
            <summary>
                A brief message about how the last service run went
            </summary>
        </member>
        <member name="T:honooru.Models.IKeyedObject">
            <summary>
                Represents an object that has an ID
            </summary>
            <remarks>
                Not named IIDedObject, cause that looks weird with the double I
            </remarks>
        </member>
        <member name="P:honooru.Models.IKeyedObject.ID">
            <summary>
                ID of the object
            </summary>
        </member>
        <member name="T:honooru.Models.AppAccount">
            <summary>
                Represents the info about an account with the app
            </summary>
        </member>
        <member name="F:honooru.Models.AppAccount.SystemID">
            <summary>
                Default ID of the system account
            </summary>
        </member>
        <member name="P:honooru.Models.AppAccount.ID">
            <summary>
                ID of the account
            </summary>
        </member>
        <member name="P:honooru.Models.AppAccount.Name">
            <summary>
                Name the owner of the account is known by
            </summary>
        </member>
        <member name="P:honooru.Models.AppAccount.Timestamp">
            <summary>
                Timestamp of when the account was created
            </summary>
        </member>
        <member name="P:honooru.Models.AppAccount.DiscordID">
            <summary>
                Discord ID of the account owner
            </summary>
        </member>
        <member name="P:honooru.Models.AppAccount.DeletedOn">
            <summary>
                When this account was deleted
            </summary>
        </member>
        <member name="P:honooru.Models.AppAccount.DeletedBy">
            <summary>
                Who deleted this account
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.AppAccountGroupMembership.ID">
            <summary>
                unique ID
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.AppAccountGroupMembership.AccountID">
            <summary>
                ID of the <see cref="T:honooru.Models.AppAccount"/> this membership is for
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.AppAccountGroupMembership.GroupID">
            <summary>
                ID of the <see cref="T:honooru.Models.Internal.AppGroup"/> this membership is for
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.AppAccountGroupMembership.Timestamp">
            <summary>
                when this entry was created
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.AppAccountGroupMembership.GrantedByAccountID">
            <summary>
                who granted the user this permission
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.AppGroup.ID">
            <summary>
                ID of the group
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.AppGroup.Name">
            <summary>
                name of the group
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.AppGroup.HexColor">
            <summary>
                hex color without the leading #
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.AppGroup.Implies">
            <summary>
                a list of <see cref="P:honooru.Models.Internal.AppGroup.ID"/>s that this group implies
            </summary>
        </member>
        <member name="T:honooru.Models.Internal.AppPermission">
            <summary>
                Permission that can be granted to a <see cref="T:honooru.Models.AppAccount"/>
            </summary>
        </member>
        <member name="F:honooru.Models.Internal.AppPermission.All">
            <summary>
                List of all <see cref="T:honooru.Models.Internal.AppPermission"/>s that exist
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.AppPermission.ID">
            <summary>
                Unique ID of the permission
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.AppPermission.Description">
            <summary>
                What this permission grants
            </summary>
        </member>
        <member name="T:honooru.Models.Internal.UnsafeAppAccount">
            <summary>
                Contains information that might not want to be kept around (such as Discord ID)
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.UnsafeAppAccount.ID">
            <summary>
                ID of the account
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.UnsafeAppAccount.Name">
            <summary>
                Name the owner of the account is known by
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.UnsafeAppAccount.Timestamp">
            <summary>
                Timestamp of when the account was created
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.UnsafeAppAccount.Email">
            <summary>
                Email of the account owner
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.UnsafeAppAccount.DiscordID">
            <summary>
                Discord ID of the account owner
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.UnsafeAppAccount.DeletedOn">
            <summary>
                When this account was deleted
            </summary>
        </member>
        <member name="P:honooru.Models.Internal.UnsafeAppAccount.DeletedBy">
            <summary>
                Who deleted this account
            </summary>
        </member>
        <member name="T:honooru.Models.AppGroupPermission">
            <summary>
                Represents a grant to let a user perform a protected action
            </summary>
        </member>
        <member name="P:honooru.Models.AppGroupPermission.ID">
            <summary>
                Unique ID of the permission
            </summary>
        </member>
        <member name="P:honooru.Models.AppGroupPermission.GroupID">
            <summary>
                What <see cref="T:honooru.Models.Internal.AppGroup"/> this permission is granted to
            </summary>
        </member>
        <member name="P:honooru.Models.AppGroupPermission.Permission">
            <summary>
                What the permission is
            </summary>
        </member>
        <member name="P:honooru.Models.AppGroupPermission.Timestamp">
            <summary>
                When this permission was added
            </summary>
        </member>
        <member name="P:honooru.Models.AppGroupPermission.GrantedByID">
            <summary>
                What <see cref="T:honooru.Models.AppAccount"/> granted this permission
            </summary>
        </member>
        <member name="T:honooru.Models.Queues.ExampleQueueEntry">
            <summary>
                Queue entries for when a session is ended
            </summary>
        </member>
        <member name="P:honooru.Models.Queues.ExampleQueueEntry.ID">
            <summary>
                ID
            </summary>
        </member>
        <member name="P:honooru.Models.Queues.ExampleQueueEntry.Timestamp">
            <summary>
                timestamp
            </summary>
        </member>
        <member name="T:honooru.Models.Queues.TagInfoUpdateQueueEntry">
            <summary>
                entry to perform an update on a <see cref="T:honooru.Models.App.TagInfo"/>
            </summary>
        </member>
        <member name="P:honooru.Models.Queues.ThumbnailCreationQueueEntry.MD5">
            <summary>
                md5 hash 
            </summary>
        </member>
        <member name="P:honooru.Models.Queues.ThumbnailCreationQueueEntry.FileExtension">
            <summary>
                file extension without a leading .
            </summary>
        </member>
        <member name="P:honooru.Models.Queues.ThumbnailCreationQueueEntry.RecreateIfNeeded">
            <summary>
                will the thumbnail be deleted and recreated if needed?
            </summary>
        </member>
        <member name="M:honooru.Models.Search.Ast.GetEnumerator">
            <summary>
                get a <see cref="T:System.Collections.Generic.IEnumerable`1"/> that iterates thru the <see cref="T:honooru.Models.Search.Node"/>s starting from the left
            </summary>
            <returns></returns>
        </member>
        <member name="M:honooru.Models.Search.NodeExtensionMethods.GetRoot(honooru.Models.Search.Node)">
            <summary>
                get the root <see cref="T:honooru.Models.Search.Node"/>, which is defined as the <see cref="T:honooru.Models.Search.Node"/> 
                with no <see cref="P:honooru.Models.Search.Node.Parent"/>
            </summary>
            <param name="node">extension instance</param>
            <returns>
                the first <see cref="T:honooru.Models.Search.Node"/> with a null <see cref="P:honooru.Models.Search.Node.Parent"/>,
                iterating upwards if <see cref="P:honooru.Models.Search.Node.Parent"/> is not null
            </returns>
        </member>
        <member name="T:honooru.Services.AppCurrentAccount">
            <summary>
                Service to get the current user making an HTTP request
            </summary>
        </member>
        <member name="M:honooru.Services.AppCurrentAccount.GetDiscord(DSharpPlus.SlashCommands.BaseContext)">
            <summary>
                Get the current user based who a <see cref="T:DSharpPlus.SlashCommands.BaseContext"/>
            </summary>
            <param name="ctx">Context of the application command</param>
            <returns>
                Null if the field <see cref="P:DSharpPlus.SlashCommands.BaseContext.Member"/> is null, or null if the user doesn't have an account
            </returns>
        </member>
        <member name="M:honooru.Services.AppCurrentAccount.Get">
            <summary>
                Get the current user, null if the user is not signed in
            </summary>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Db.AppAccountAccessLogDbStore.Insert(honooru.Models.AppAccountAccessLog)">
            <summary>
                Insert a new <see cref="T:honooru.Models.AppAccountAccessLog"/> to the DB
            </summary>
            <param name="log">Parameters used to insert</param>
            <exception cref="T:System.ArgumentException">
                Throw if both <see cref="P:honooru.Models.AppAccountAccessLog.AccountID"/> and <see cref="P:honooru.Models.AppAccountAccessLog.Email"/> is null
            </exception>
        </member>
        <member name="M:honooru.Services.Db.AppAccountDbStore.GetByID(System.Int64,System.Threading.CancellationToken)">
            <summary>
                Get a specific <see cref="T:honooru.Models.AppAccount"/> by its ID
            </summary>
            <param name="ID">ID of the account to get</param>
            <param name="cancel">Cancellation token</param>
            <returns>
                The <see cref="T:honooru.Models.AppAccount"/> with <see cref="P:honooru.Models.AppAccount.ID"/> of <paramref name="ID"/>,
                or <c>null</c> if it does not exist
            </returns>
        </member>
        <member name="M:honooru.Services.Db.AppAccountDbStore.GetAll(System.Threading.CancellationToken)">
            <summary>
                Get all <see cref="T:honooru.Models.AppAccount"/>s
            </summary>
            <param name="cancel">Cancellation token</param>
            <returns>
                A list of all <see cref="T:honooru.Models.AppAccount"/>s, including ones that are deactivated
            </returns>
        </member>
        <member name="M:honooru.Services.Db.AppAccountDbStore.GetByDiscordID(System.UInt64,System.Threading.CancellationToken)">
            <summary>
                Get a <see cref="T:honooru.Models.AppAccount"/> by <see cref="P:honooru.Models.AppAccount.DiscordID"/>
            </summary>
            <param name="discordID">ID of the discord account to get the account of</param>
            <param name="cancel">Cancellation token</param>
            <returns>
                The <see cref="T:honooru.Models.AppAccount"/> with <see cref="P:honooru.Models.AppAccount.DiscordID"/> of <paramref name="discordID"/>,
                or <c>null</c> if it does not exist
            </returns>
        </member>
        <member name="M:honooru.Services.Db.AppAccountDbStore.Insert(honooru.Models.AppAccount,System.Threading.CancellationToken)">
            <summary>
                Insert a new <see cref="T:honooru.Models.AppAccount"/>
            </summary>
            <param name="param">Parameters used to insert the new account</param>
            <param name="cancel">Cancellation token</param>
            <returns>
                The <see cref="P:honooru.Models.AppAccount.ID"/> of the row that was newly inserted in the DB
            </returns>
        </member>
        <member name="M:honooru.Services.Db.AppAccountDbStore.Delete(System.Int64,System.UInt64,System.Threading.CancellationToken)">
            <summary>
                Delete an account, marking it as deactive
            </summary>
            <param name="accountID">ID of the account to delete</param>
            <param name="deletedByID">ID of the account that is performing the delete</param>
            <param name="cancel">Cancellation token</param>
            <returns>
                When the operation has completed
            </returns>
        </member>
        <member name="M:honooru.Services.Db.AppAccountGroupMembershipDbStore.GetByAccountID(System.UInt64)">
            <summary>
                get the group memberships a user is a part of
            </summary>
            <param name="accountID">ID of the account to get the memberships of</param>
            <returns>
                
            </returns>
        </member>
        <member name="M:honooru.Services.Db.AppAccountGroupMembershipDbStore.GetByGroupID(System.UInt64)">
            <summary>
                get the group memberships a user is a part of
            </summary>
            <param name="groupID">ID of the group to get the memberships of</param>
            <returns>
                
            </returns>
        </member>
        <member name="M:honooru.Services.Db.AppGroupPermissionDbStore.GetByID(System.Int64)">
            <summary>
                Get a single group permission by its ID
            </summary>
            <param name="ID">ID of the specific permission to get</param>
        </member>
        <member name="M:honooru.Services.Db.AppGroupPermissionDbStore.GetByGroupID(System.UInt64)">
            <summary>
                Get the account permissions of a group
            </summary>
            <param name="groupID">ID of the group</param>
        </member>
        <member name="M:honooru.Services.Db.AppGroupPermissionDbStore.Insert(honooru.Models.AppGroupPermission)">
            <summary>
                Insert a new <see cref="T:honooru.Models.AppGroupPermission"/>
            </summary>
            <param name="perm">Parameters used to insert</param>
            <returns>The ID the row was given in the table</returns>
            <exception cref="T:System.ArgumentException">If one of the fields in <paramref name="perm"/> was invalid</exception>
        </member>
        <member name="M:honooru.Services.Db.AppGroupPermissionDbStore.DeleteByID(System.Int64)">
            <summary>
                Delete a specific <see cref="T:honooru.Models.AppGroupPermission"/> by its ID
            </summary>
            <param name="ID">ID of the permission to delete</param>
        </member>
        <member name="T:honooru.Services.Db.AppMetadataDbStore">
            <summary>
                DB service that interacts with the metadata table
            </summary>
        </member>
        <member name="M:honooru.Services.Db.AppMetadataDbStore.Get(System.String)">
            <summary>
                Read a single value from the metadata DB
            </summary>
            <param name="key">key of the object to get</param>
            <returns>
                The string value of the metadata key, or <c>null</c> if it doesn't exist
            </returns>
        </member>
        <member name="M:honooru.Services.Db.AppMetadataDbStore.Upsert(System.String,System.String)">
            <summary>
                Update/Insert (upsert) a value in the metadata DB table
            </summary>
            <param name="key">key to upsert</param>
            <param name="value">value to set</param>
            <returns>
                A task for when the async operation is complete
            </returns>
        </member>
        <member name="M:honooru.Services.Db.ExpEventDbStore.LoadWrapped(System.String,System.DateTime)">
            <summary>
                Load wrapped exp data for a character in a year
            </summary>
            <param name="charID"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="T:honooru.Services.Db.IDataReader`1">
            <summary>
            A generic data reader that wraps reading a single entry and list safey 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:honooru.Services.Db.IDataReader`1.ReadEntry(Npgsql.NpgsqlDataReader)">
            <summary>
                Read a single row of data and turn it into the generic type <typeparamref name="T"/>
            </summary>
            <param name="reader">Reader the read is being performed on</param>
            <returns>
                The row in <paramref name="reader"/> represents as the generic type, or <c>null</c>
                if the data within the reader could not produce a valid output
            </returns>
        </member>
        <member name="M:honooru.Services.Db.IDataReader`1.ReadList(Npgsql.NpgsqlCommand)">
            <summary>
            Read a list of rows from a <see cref="T:Npgsql.NpgsqlCommand"/>
            </summary>
            <param name="cmd">Command to read the list from</param>
            <returns>A list of type <typeparamref name="T"/>. If no rows are read, an empty list is returned, not null</returns>
        </member>
        <member name="M:honooru.Services.Db.IDataReader`1.ReadList(Npgsql.NpgsqlCommand,System.Threading.CancellationToken)">
            <summary>
                Read a list of rows from a <see cref="T:Npgsql.NpgsqlCommand"/>
            </summary>
            <param name="cmd">Command to read the list from</param>
            <param name="cancel">Cancel token</param>
            <returns>
                A list of type <typeparamref name="T"/>. If no rows are read, an empty list is returned, not null
            </returns>
        </member>
        <member name="M:honooru.Services.Db.IDataReader`1.ReadSingle(Npgsql.NpgsqlCommand)">
            <summary>
                Read a single entry from a <see cref="T:Npgsql.NpgsqlCommand"/>
            </summary>
            <param name="cmd">Command to read the entry from</param>
            <returns>
                The value read from the command or null if no rows were returned
            </returns>
        </member>
        <member name="M:honooru.Services.Db.IDataReader`1.ReadSingle(Npgsql.NpgsqlCommand,System.Threading.CancellationToken)">
            <summary>
                Read a single entry from a <see cref="T:Npgsql.NpgsqlCommand"/>
            </summary>
            <param name="cmd">Command to read the entry from</param>
            <param name="cancel">Cancel token</param>
            <returns>
                The value read from the command or null if no rows were returned
            </returns>
        </member>
        <member name="T:honooru.Services.Db.IDbCreator">
            <summary>
            Creates and updates the database
            </summary>
        </member>
        <member name="M:honooru.Services.Db.IDbCreator.Execute">
            <summary>
            Execute the creator
            </summary>
        </member>
        <member name="M:honooru.Services.Db.IDbHelper.Connection(System.String,System.String,System.Boolean)">
            <summary>
            Create a new connection to the database given in the db options
            </summary>
            <param name="server">Name of the server. Currently setup for 'events' and 'character'</param>
            <param name="task">Optional name to use about the application, defaults to 'honooru'</param>
            <param name="enlist">Will this connection enlist to the TransactionScope?</param>
            <returns>A new connection to use</returns>
        </member>
        <member name="M:honooru.Services.Db.IDbHelper.Command(Npgsql.NpgsqlConnection,System.String)">
            <summary>
            Create a new command using the connection passed
            </summary>
            <param name="connection">Connection the command will be executed on</param>
            <param name="text">Text of the command</param>
        </member>
        <member name="T:honooru.Services.Db.Dbs">
            <summary>
                Names of connection strings
            </summary>
        </member>
        <member name="F:honooru.Services.Db.Dbs.MAIN">
            <summary>
                main
            </summary>
        </member>
        <member name="M:honooru.Services.Db.IDbHelperExtensions.HasIndex(honooru.Services.Db.IDbHelper,System.String,System.String)">
            <summary>
                Check if an index exists
            </summary>
            <param name="instance">Extension instance</param>
            <param name="tableName">Table the index is for</param>
            <param name="indexName">Index name on the table</param>
            <returns>
                A boolean value if the index exists on that table
            </returns>
        </member>
        <member name="T:honooru.Services.Db.IDbPatch">
            <summary>
            A patch performed on the database
            </summary>
        </member>
        <member name="P:honooru.Services.Db.IDbPatch.MinVersion">
            <summary>
            Minimum version, if the verison of the database is lower than this the patch won't be executed
            </summary>
        </member>
        <member name="P:honooru.Services.Db.IDbPatch.Name">
            <summary>
            Name of the patch
            </summary>
        </member>
        <member name="M:honooru.Services.Db.IDbPatch.Execute(honooru.Services.Db.IDbHelper)">
            <summary>
            Execute the patch
            </summary>
        </member>
        <member name="M:honooru.Services.Db.Implementations.DefaultDbCreator.GetPatches">
            <summary>
                Get all the patches loaded in the currently assembly
            </summary>
        </member>
        <member name="M:honooru.Services.Db.Implementations.DefaultDbCreator.UpdateVersion(System.Int32)">
            <summary>
                Update the DB version
            </summary>
        </member>
        <member name="M:honooru.Services.Db.Implementations.DefaultDbCreator.GetVersion">
            <summary>
                Get the current DB version, or -1 if no tables have been created, or an error occurs
            </summary>
        </member>
        <member name="M:honooru.Services.Db.Implementations.DefaultDbCreator.DoesMetadataTableExist">
            <summary>
                Check if the metadata table exists
            </summary>
        </member>
        <member name="M:honooru.Services.Db.Implementations.DbHelper.Connection(System.String,System.String,System.Boolean)">
            <summary>
                Create a new connection to the database
            </summary>
            <remarks>
                The following additional properties are set on the connection:
                    <br/>
                    'Include Error Detail'=true
                    <br/>
                    ApplicationName='Annuls'
                    <br/>
                    Timezone=UTC
            </remarks>
            <returns>
                A new <see cref="T:Npgsql.NpgsqlConnection"/>
            </returns>
        </member>
        <member name="M:honooru.Services.Db.Implementations.DbHelper.Command(Npgsql.NpgsqlConnection,System.String)">
            <summary>
                Create a new command, using the connection passed
            </summary>
            <remarks>
                The resulting <see cref="T:Npgsql.NpgsqlCommand"/> will have <see cref="P:System.Data.Common.DbCommand.CommandType"/> of <see cref="F:System.Data.CommandType.Text"/>,
                and <see cref="P:System.Data.Common.DbCommand.CommandText"/> of <paramref name="text"/>
            </remarks>
            <param name="connection">Connection to create the command on</param>
            <param name="text">Command text</param>
            <returns>
                A new <see cref="T:Npgsql.NpgsqlCommand"/> ready to be used
            </returns>
        </member>
        <member name="M:honooru.Services.Db.MediaAssetDb.GetAll">
            <summary>
                get all <see cref="T:honooru.Models.App.MediaAsset"/>s
            </summary>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Db.MediaAssetDb.GetByID(System.Guid)">
            <summary>
                get a single <see cref="T:honooru.Models.App.MediaAsset"/> by it's <see cref="P:honooru.Models.App.MediaAsset.Guid"/>
            </summary>
            <param name="guid">Guid of the <see cref="T:honooru.Models.App.MediaAsset"/> to get</param>
            <returns>
                the <see cref="T:honooru.Models.App.MediaAsset"/> with <see cref="P:honooru.Models.App.MediaAsset.Guid"/> of <paramref name="guid"/>,
                or <c>null</c> if it does not exist
            </returns>
        </member>
        <member name="M:honooru.Services.Db.MediaAssetDb.GetByMD5(System.String)">
            <summary>
                get a <see cref="T:honooru.Models.App.MediaAsset"/> by <see cref="P:honooru.Models.App.MediaAsset.MD5"/>
            </summary>
            <param name="md5">md5 hash</param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Db.MediaAssetDb.Delete(System.Guid)">
            <summary>
                delete a <see cref="T:honooru.Models.App.MediaAsset"/> from the DB
            </summary>
            <param name="assetID"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Db.PostDb.GetAll">
            <summary>
                get all <see cref="T:honooru.Models.Db.Post"/>s
            </summary>
            <returns>a list of <see cref="T:honooru.Models.Db.Post"/>s</returns>
        </member>
        <member name="M:honooru.Services.Db.PostDb.Search(honooru.Models.Api.SearchQuery,honooru.Models.AppAccount)">
            <summary>
                perform a search
            </summary>
            <param name="query">query that will be performed. use a <see cref="T:honooru.Services.Parsing.SearchQueryParser"/> to obtain this from a string</param>
            <param name="user">
                account of the user making the request. used for filtering unsafe/explicit content if the user does not want to see it
            </param>
            <returns>
                a list of <see cref="T:honooru.Models.Db.Post"/>s that fulfill the search parameters from <paramref name="query"/>
            </returns>
        </member>
        <member name="M:honooru.Services.Db.PostDb.GetByID(System.UInt64)">
            <summary>
                get a single <see cref="T:honooru.Models.Db.Post"/> by its <see cref="P:honooru.Models.Db.Post.ID"/>
            </summary>
            <param name="ID">ID of the <see cref="T:honooru.Models.Db.Post"/> to get</param>
            <returns>
                the <see cref="T:honooru.Models.Db.Post"/> with <see cref="P:honooru.Models.Db.Post.ID"/> of <paramref name="ID"/>,
                or <c>null</c> if it does not exist
            </returns>
        </member>
        <member name="M:honooru.Services.Db.PostDb.GetByMD5(System.String)">
            <summary>
                get a single <see cref="T:honooru.Models.Db.Post"/> by its <see cref="P:honooru.Models.Db.Post.MD5"/>
            </summary>
            <param name="md5">lower case md5 string</param>
            <returns>
                the <see cref="T:honooru.Models.Db.Post"/> with <see cref="P:honooru.Models.Db.Post.MD5"/> of <paramref name="md5"/>,
                or <c>null</c> if it does not exist
            </returns>
        </member>
        <member name="M:honooru.Services.Db.PostDb.Insert(honooru.Models.Db.Post)">
            <summary>
                insert a new <see cref="T:honooru.Models.Db.Post"/>, returning the ID of the newly created DB entry
            </summary>
            <param name="post">parameters used to insert</param>
            <returns>
                the <see cref="P:honooru.Models.Db.Post.ID"/> of the DB entry that was just inserted
            </returns>
        </member>
        <member name="M:honooru.Services.Db.PostDb.Update(System.UInt64,honooru.Models.Db.Post)">
            <summary>
                update an existing <see cref="T:honooru.Models.Db.Post"/> with new information
            </summary>
            <param name="postID"></param>
            <param name="post"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Db.TagDb.GetAll(System.Threading.CancellationToken)">
            <summary>
                get all <see cref="T:honooru.Models.App.Tag"/>s in the DB
            </summary>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Db.TagDb.GetByID(System.UInt64)">
            <summary>
                get a single <see cref="T:honooru.Models.App.Tag"/> by its <see cref="P:honooru.Models.App.Tag.ID"/>
            </summary>
            <param name="ID"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Db.TagDb.GetByName(System.String)">
            <summary>
                get a <see cref="T:honooru.Models.App.Tag"/> by its <see cref="P:honooru.Models.App.Tag.Name"/>, which is unique
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Db.TagDb.Insert(honooru.Models.App.Tag)">
            <summary>
                Insert a new <see cref="T:honooru.Models.App.Tag"/>
            </summary>
            <param name="tag"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:honooru.Services.Db.TagDb.Update(honooru.Models.App.Tag)">
            <summary>
                update an existing <see cref="T:honooru.Models.App.Tag"/>
            </summary>
            <param name="tag"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:honooru.Services.DiscordWrapper">
            <summary>
                A wrapper around a <see cref="T:DSharpPlus.DiscordClient"/>, used as a singleton so multiple services can share a client
            </summary>
        </member>
        <member name="F:honooru.Services.DiscordWrapper._CachedMembership">
            <summary>
                Cache of what guild a user is found in
            </summary>
        </member>
        <member name="M:honooru.Services.DiscordWrapper.GetDiscordMember(System.UInt64)">
            <summary>
                Get a <see cref="T:DSharpPlus.Entities.DiscordMember"/> from an ID
            </summary>
            <param name="memberID">ID of the Discord member to get</param>
            <returns>
                The <see cref="T:DSharpPlus.Entities.DiscordMember"/> with the corresponding ID, or <c>null</c>
                if the user could not be found in any guild the bot is a part of
            </returns>
        </member>
        <member name="F:honooru.Services.Hosted.BaseQueueProcessor`1._ServiceName">
            <summary>
                Name of the service. Can be disabled using commands
            </summary>
        </member>
        <member name="M:honooru.Services.Hosted.BaseQueueProcessor`1._ProcessQueueEntry(`0,System.Threading.CancellationToken)">
            <summary>
                Process a queue entry, returning true if the duration of processing that entry is to be recorded
            </summary>
            <param name="entry">Queue entry to be processed</param>
            <param name="cancel">Stopping token</param>
            <returns>
                A boolean value indicating if the time it took to process this entry will be recorded
            </returns>
        </member>
        <member name="M:honooru.Services.Hosted.DiscordService.GetDiscordMember(System.UInt64)">
            <summary>
                Get a <see cref="T:DSharpPlus.Entities.DiscordMember"/> from an ID
            </summary>
            <param name="memberID">ID of the Discord member to get</param>
            <returns>
                The <see cref="T:DSharpPlus.Entities.DiscordMember"/> with the corresponding ID, or <c>null</c>
                if the user could not be found in any guild the bot is a part of
            </returns>
        </member>
        <member name="M:honooru.Services.Hosted.DiscordService.Client_Ready(DSharpPlus.DiscordClient,DSharpPlus.EventArgs.ReadyEventArgs)">
            <summary>
                Event handler for when the client is ready
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Hosted.DiscordService.Generic_Interaction_Created(DSharpPlus.DiscordClient,DSharpPlus.EventArgs.InteractionCreateEventArgs)">
            <summary>
                Event handler for both types of interaction (slash commands and context menu)
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Hosted.DiscordService.Button_Command_Executed(DSharpPlus.ButtonCommands.ButtonCommandsExtension,DSharpPlus.ButtonCommands.EventArgs.ButtonCommandExecutionEventArgs)">
            <summary>
                Event handler for when a button command is executed
            </summary>
            <param name="ext"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Hosted.DiscordService.Button_Command_Error(DSharpPlus.ButtonCommands.ButtonCommandsExtension,DSharpPlus.ButtonCommands.EventArgs.ButtonCommandErrorEventArgs)">
            <summary>
                Event handler for when an exception is thrown during the execution of a button command
            </summary>
            <param name="ext"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Hosted.DiscordService.Slash_Command_Errored(DSharpPlus.SlashCommands.SlashCommandsExtension,DSharpPlus.SlashCommands.EventArgs.SlashCommandErrorEventArgs)">
            <summary>
                Event handler for when a slash command fails
            </summary>
            <param name="ext"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Hosted.DiscordService.Context_Menu_Errored(DSharpPlus.SlashCommands.SlashCommandsExtension,DSharpPlus.SlashCommands.EventArgs.ContextMenuErrorEventArgs)">
            <summary>
                Event handler for when a context menu command fails
            </summary>
            <param name="ext"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Hosted.DiscordService.ConvertMentionable(honooru.Models.Discord.DiscordMention)">
            <summary>
                Convert the app wrapper for a discord mention into whatever library we're using
            </summary>
            <param name="mention"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">If the <paramref name="mention"/>'s <see cref="P:honooru.Models.Discord.DiscordMention.MentionType"/> was unhandled</exception>
        </member>
        <member name="M:honooru.Services.Hosted.DiscordService.GetCommandString(System.Collections.Generic.IEnumerable{DSharpPlus.Entities.DiscordInteractionDataOption})">
            <summary>
                Transform the options used in an interaction into a string that can be viewed
            </summary>
            <param name="options"></param>
        </member>
        <member name="T:honooru.Services.Hosted.DbCreatorStartupService">
            <summary>
            Startup service that runs the DB creator, going thru all patches to ensure the database is ready to run
            
            If this fails, the exception is thrown, as the app likely can't run at this point
            </summary>
        </member>
        <member name="T:honooru.Services.ExampleBackgroundService">
            <summary>
                example background service that performs a task periodically
            </summary>
        </member>
        <member name="M:honooru.Services.HttpUtilService.GetUserAgent(Microsoft.AspNetCore.Http.HttpContext)">
            <summary>
                Get the user agent of request of an HttpContext, returning null if it was not provided
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.HttpUtilService.IsSearchEngineBot(Microsoft.AspNetCore.Http.HttpContext)">
            <summary>
                Check if a request comes from a search engine bot (based on user agent)
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:honooru.Services.InstanceInfo">
            <summary>
                Get instance specific information about the running instance
            </summary>
        </member>
        <member name="M:honooru.Services.InstanceInfo.GetHost">
            <summary>
                Get the web host of this instance. Defaults to localhost if not given
            </summary>
        </member>
        <member name="M:honooru.Services.IqdbClient.UpdateHealth">
            <summary>
                perform a health update of the IQDB service
            </summary>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.IqdbClient.CheckHealth">
            <summary>
                check the health of the external IQDB service
            </summary>
            <returns>
                a <see cref="T:honooru.Models.ServiceHealthEntry"/> for the service
            </returns>
        </member>
        <member name="M:honooru.Services.IqdbClient.GetByPostID(System.String)">
            <summary>
                get a <see cref="T:honooru.Models.App.IqdbEntry"/> from the IQDB service
            </summary>
            <param name="postID">ID of the post to get from the IQDB service, usually an md5 hash</param>
            <returns>
                the <see cref="T:honooru.Models.App.IqdbEntry"/> with <see cref="P:honooru.Models.App.IqdbEntry.PostID"/> of <paramref name="postID"/>,
                or <c>null</c> if the IQDB service does not have it
            </returns>
            <exception cref="T:System.Exception">if the response from the IQDB service did not have the correct fields</exception>
        </member>
        <member name="M:honooru.Services.IqdbClient.GetSimilar(System.String)">
            <summary>
                using an IQDB image hash (which is a HAAR signarture), get similar images to the input hash
            </summary>
            <param name="iqdb">hash. must starts with the string "iqdb_"</param>
            <returns>
                a list of <see cref="T:honooru.Models.App.Iqdb.IqdbQueryResult"/> from the IQDB service, in descending or (Z->A)
                based on <see cref="P:honooru.Models.App.Iqdb.IqdbQueryResult.Score"/>. all values in <see cref="P:honooru.Models.App.Iqdb.IqdbQueryResult.Post"/> are null.
                <br></br>
                an empty list is returned if the IQDB service is not available
            </returns>
            <exception cref="T:System.Exception">
                if <paramref name="iqdb"/> is not valid
            </exception>
        </member>
        <member name="M:honooru.Services.IqdbClient.Create(System.String,System.String,System.String)">
            <summary>
                create a new <see cref="T:honooru.Models.App.IqdbEntry"/>
            </summary>
            <param name="path">path that the file is read from</param>
            <param name="md5">md5 of the upload. usually the MD5 of the post, but it can be appended with -frame-# for video uploads</param>
            <param name="fileExt">extension of the file</param>
            <returns>
                a <see cref="T:honooru.Models.App.IqdbEntry"/> that was created, or <c>null</c> if the IQDB service is not reachable
            </returns>
        </member>
        <member name="M:honooru.Services.IqdbClient.Insert(System.Byte[],System.String,System.String)">
            <summary>
                insert a new entry, used as video hashing creates multiple entries
            </summary>
            <param name="bytes">bytes of the jpg file</param>
            <param name="name"></param>
            <param name="md5"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:honooru.Services.IqdbClient.Remove(System.String)">
            <summary>
                remove an IQDB entry from the IQDB service
            </summary>
            <param name="postID"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Parsing.AstBuilder._c(honooru.Models.Search.NodeType,honooru.Models.Search.Token,honooru.Models.Search.Node)">
            <summary>
                helper function to create a Node, and add it to the <see cref="P:honooru.Models.Search.Node.Children"/> of <paramref name="parent"/>
            </summary>
            <param name="type"></param>
            <param name="token"></param>
            <param name="parent"></param>
            <returns>
                the newly created node
            </returns>
        </member>
        <member name="F:honooru.Services.Queues.BasePendingQueue`2._Pending">
            <summary>
                Set of pending entries to be updated
            </summary>
        </member>
        <member name="M:honooru.Services.Queues.BasePendingQueue`2.Dequeue(System.Threading.CancellationToken)">
            <summary>
                Get the next item in the list. This will block until there is one available
            </summary>
            <param name="cancel">Stopping token</param>
        </member>
        <member name="M:honooru.Services.Queues.BasePendingQueue`2.TryDequeue">
            <summary>
                Attempt to dequeue an entry from the queue. If no entry is in the queue, the return value will be null.
                This call will not block until there is an entry in the queue, unlike <see cref="M:honooru.Services.Queues.BasePendingQueue`2.Dequeue(System.Threading.CancellationToken)"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Queues.BasePendingQueue`2.Peak(System.Threading.CancellationToken)">
            <summary>
                Peak at the next item in the queue. This will block until there is one available.
                DO NOT USE THIS WITH MULTIPLER WORKERS. If you have multiple background processors using Peak,
                they will be working on the same <typeparamref name="T"/>!
            </summary>
            <param name="cancel">Stopping token</param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Queues.BasePendingQueue`2.QueueAtFront(`0)">
            <summary>
                Insert a new entry into the front of the queue. Use this sparingly,
                as in order to insert at the top of the list, a copy of the list must be allocated,
                the items are cleared, then each item is re-queued behind <paramref name="entry"/>
            </summary>
            <param name="entry">Entry to be queued at the front</param>
        </member>
        <member name="M:honooru.Services.Queues.BasePendingQueue`2.Queue(`0)">
            <summary>
                Queue a new entry into the queue
            </summary>
        </member>
        <member name="M:honooru.Services.Queues.BasePendingQueue`2.GetEntryID(`0)">
            <summary>
                Get the ID of the <typeparamref name="T"/> based on a specific instance of the object
            </summary>
            <param name="entry"></param>
            <returns>
                <typeparamref name="U"/>, which is used as a key to preventing duplicate entries from being entered into the queue
            </returns>
        </member>
        <member name="F:honooru.Services.Queues.BaseQueue`1._Items">
            <summary>
                queue of the items to be pulled out
            </summary>
        </member>
        <member name="F:honooru.Services.Queues.BaseQueue`1._Signal">
            <summary>
                a signal for when an item is in the queue
            </summary>
        </member>
        <member name="F:honooru.Services.Queues.BaseQueue`1._ProcessTime">
            <summary>
                how long it takes each item in the queue to be processed in some way
            </summary>
        </member>
        <member name="F:honooru.Services.Queues.BaseQueue`1._ProcessedCount">
            <summary>
                how many items have been processed in this queue
            </summary>
        </member>
        <member name="M:honooru.Services.Queues.BaseQueue`1.Dequeue(System.Threading.CancellationToken)">
            <summary>
                Get the next item in the list. This will block until there is one available
            </summary>
            <param name="cancel">Stopping token</param>
        </member>
        <member name="M:honooru.Services.Queues.BaseQueue`1.TryDequeue">
            <summary>
                Attempt to dequeue an entry from the queue. If no entry is in the queue, the return value will be null.
                This call will not block until there is an entry in the queue, unlike <see cref="M:honooru.Services.Queues.BaseQueue`1.Dequeue(System.Threading.CancellationToken)"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Queues.BaseQueue`1.Peak(System.Threading.CancellationToken)">
            <summary>
                Peak at the next item in the queue. This will block until there is one available.
                DO NOT USE THIS WITH MULTIPLER WORKERS. If you have multiple background processors using Peak,
                they will be working on the same <typeparamref name="T"/>!
            </summary>
            <param name="cancel">Stopping token</param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Queues.BaseQueue`1.QueueAtFront(`0)">
            <summary>
                Insert a new entry into the front of the queue. Use this sparingly,
                as in order to insert at the top of the list, a copy of the list must be allocated,
                the items are cleared, then each item is re-queued behind <paramref name="entry"/>
            </summary>
            <param name="entry">Entry to be queued at the front</param>
        </member>
        <member name="M:honooru.Services.Queues.BaseQueue`1.Queue(`0)">
            <summary>
                Queue a new entry into the queue
            </summary>
        </member>
        <member name="M:honooru.Services.Queues.BaseQueue`1.AddProcessTime(System.Int64)">
            <summary>
                Add some basic metrics about how long it took to process "something" in the queue
            </summary>
            <param name="ms">How many milliseconds it took to process something that came from this queue</param>
        </member>
        <member name="M:honooru.Services.Queues.BaseQueue`1.GetProcessTime">
            <summary>
                Get a copy of a list that contains how many milliseconds it took to process data in this queue
            </summary>
            <returns>
                A newly allocated list whose elements represent how long it took to process data from this queue
            </returns>
        </member>
        <member name="M:honooru.Services.Queues.BaseQueue`1.Count">
            <summary>
                Get how many entries are in the queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Queues.BaseQueue`1.Processed">
            <summary>
                Return how many items have been removed from this queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Queues.BaseQueue`1.ToList">
            <summary>
                Allocate a copy of the items in the list
            </summary>
            <returns>A newly allocated list that contains a shallow-reference to the items in the list</returns>
        </member>
        <member name="T:honooru.Services.Queues.DiscordMessageQueue">
            <summary>
                Queue of messages to be sent in Discord
            </summary>
        </member>
        <member name="M:honooru.Services.Queues.ServiceCollectionExtentionMethods.AddAppQueueServices(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
                And the various queues the app uses
            </summary>
            <param name="services">Extension instance</param>
        </member>
        <member name="M:honooru.Services.Repositories.AppMetadataRepository.Get(System.String)">
            <summary>
                Get a metadata value
            </summary>
            <param name="key">case-insensitive key to get</param>
            <returns>
                Null if no value is set, otherwise the string value
            </returns>
        </member>
        <member name="M:honooru.Services.Repositories.AppMetadataRepository.Upsert(System.String,System.String)">
            <summary>
                Update/Insert (upsert) a metadata value
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.AppMetadataRepositoryExtensions.GetAsBoolean(honooru.Services.Repositories.AppMetadataRepository,System.String)">
            <summary>
                Get a value as a string. Keys are case-insensitive!
            </summary>
            <param name="repo">extension instance</param>
            <param name="key">key of the obj</param>
            <returns>
                A nullable boolean value based on the string value read from the DB
            </returns>
            <exception cref="T:System.FormatException">
                If the value read from the DB was not "true" or "false", the only valid values (or null)
            </exception>
        </member>
        <member name="M:honooru.Services.Repositories.AppMetadataRepositoryExtensions.Upsert(honooru.Services.Repositories.AppMetadataRepository,System.String,System.Boolean)">
            <summary>
                Upsert a boolean
            </summary>
            <param name="repo"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:honooru.Services.Repositories.AppPermissionRepository">
            <summary>
                Repository to interact with <see cref="T:honooru.Models.AppGroupPermission"/>s
            </summary>
        </member>
        <member name="M:honooru.Services.Repositories.AppPermissionRepository.GetByID(System.Int64)">
            <summary>
                Get a specific <see cref="T:honooru.Models.AppGroupPermission"/> by its ID, or null if it doens't exist
            </summary>
        </member>
        <member name="M:honooru.Services.Repositories.AppPermissionRepository.GetByGroupID(System.UInt64)">
            <summary>
                Get the <see cref="T:honooru.Models.AppGroupPermission"/>s of a group
            </summary>
            <param name="groupID">ID of the group</param>
        </member>
        <member name="M:honooru.Services.Repositories.AppPermissionRepository.Insert(honooru.Models.AppGroupPermission)">
            <summary>
                Insert a new <see cref="T:honooru.Models.AppGroupPermission"/>, returning the ID it has after being inserted
            </summary>
        </member>
        <member name="M:honooru.Services.Repositories.AppPermissionRepository.DeleteByID(System.Int64)">
            <summary>
                Delete a <see cref="T:honooru.Models.AppGroupPermission"/>
            </summary>
            <param name="ID"></param>
            <returns></returns>
        </member>
        <member name="T:honooru.Services.Repositories.AppGroupPermissionRepositoryExtensionMethods">
            <summary>
                Useful extensions method for a <see cref="T:honooru.Services.Repositories.AppPermissionRepository"/>
            </summary>
        </member>
        <member name="M:honooru.Services.Repositories.AppGroupPermissionRepositoryExtensionMethods.GetPermissionByGroup(honooru.Services.Repositories.AppPermissionRepository,honooru.Models.Internal.AppGroup,System.String[])">
            <summary>
                Get the <see cref="T:honooru.Models.AppGroupPermission"/> for a <see cref="T:honooru.Models.AppAccount"/> based on a list of permissions
            </summary>
            <param name="repo">Extension instance</param>
            <param name="group">group to get the permission of</param>
            <param name="permissions">Permissions to return</param>
            <returns>
                The first <see cref="T:honooru.Models.AppGroupPermission"/> that the account <paramref name="group"/> has that matches
                one of the permission keys in <paramref name="permissions"/>.
                Or <c>null</c> if the user does not have any of those permissions
            </returns>
        </member>
        <member name="M:honooru.Services.Repositories.AppGroupPermissionRepositoryExtensionMethods.GetPermissionByGroupID(honooru.Services.Repositories.AppPermissionRepository,System.UInt64,System.String[])">
            <summary>
                Get the <see cref="T:honooru.Models.AppGroupPermission"/> for a <see cref="T:honooru.Models.AppAccount"/> based on a list of permissions
            </summary>
            <param name="repo">Extension instance</param>
            <param name="groupID">ID of the group to get the permission of</param>
            <param name="permissions">Permissions to return</param>
            <returns>
                The first <see cref="T:honooru.Models.AppGroupPermission"/> that the account with <see cref="P:honooru.Models.AppAccount.ID"/>
                of <paramref name="groupID"/> has that matches one of the permission keys in <paramref name="permissions"/>.
                Or <c>null</c> if the user does not have any of those permissions
            </returns>
        </member>
        <member name="M:honooru.Services.Repositories.MediaAssetRepository.Delete(System.Guid)">
            <summary>
                delete a <see cref="T:honooru.Models.App.MediaAsset"/>. use <see cref="M:honooru.Services.Repositories.MediaAssetRepository.Erase(System.Guid)"/> if you want to remove the files as well
            </summary>
            <param name="assetID">ID of the asset to delete</param>
            <returns>a task once the async operation is complete</returns>
        </member>
        <member name="M:honooru.Services.Repositories.MediaAssetRepository.Erase(System.Guid)">
            <summary>
                erase a <see cref="T:honooru.Models.App.MediaAsset"/>, which also deletes all files associated with it
            </summary>
            <param name="assetID"></param>
            <returns></returns>
        </member>
        <member name="T:honooru.Services.Repositories.TagRepository">
            <summary>
                repository service for managing <see cref="T:honooru.Models.App.Tag"/>s
            </summary>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.GetAll(System.Threading.CancellationToken)">
            <summary>
                get a list of all <see cref="T:honooru.Models.App.Tag"/>s
            </summary>
            <param name="cancel">cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.GetAll">
            <summary>
                get a list of all <see cref="T:honooru.Models.App.Tag"/>s
            </summary>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository._GetDictionary">
            <summary>
                get the list of <see cref="T:honooru.Models.App.Tag"/>s but as a dictionary
            </summary>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.GetByID(System.UInt64)">
            <summary>
                get a <see cref="T:honooru.Models.App.Tag"/> by its <see cref="P:honooru.Models.App.Tag.ID"/>
            </summary>
            <param name="tagID">ID of the <see cref="T:honooru.Models.App.Tag"/> to get</param>
            <returns>
                the <see cref="T:honooru.Models.App.Tag"/> with <see cref="P:honooru.Models.App.Tag.ID"/> of <paramref name="tagID"/>,
                or <c>null</c> if it does not exist
            </returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.GetByIDs(System.Collections.Generic.IEnumerable{System.UInt64})">
            <summary>
                get all <see cref="T:honooru.Models.App.Tag"/>s with an <see cref="P:honooru.Models.App.Tag.ID"/> in <paramref name="tagIds"/>
            </summary>
            <param name="tagIds"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.GetByName(System.String)">
            <summary>
                get an existing <see cref="T:honooru.Models.App.Tag"/> by its <see cref="P:honooru.Models.App.Tag.Name"/>,
                or <c>null</c> if it does not exist
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.GetOrCreateByName(System.String,honooru.Models.App.TagType)">
            <summary>
                get an existing <see cref="T:honooru.Models.App.Tag"/> by <see cref="P:honooru.Models.App.Tag.Name"/>,
                and optionally update the <see cref="P:honooru.Models.App.Tag.TypeID"/> to match <paramref name="type"/>,
                or create a new one with a <see cref="P:honooru.Models.App.Tag.TypeID"/> from <paramref name="type"/>, (default to 1)
                if it does not exist
            </summary>
            <param name="name"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.SearchByName(System.String,System.Threading.CancellationToken)">
            <summary>
                perform a search for tags based on name. searching is based on 
                if the tag name contains <paramref name="name"/>, or the levenshtein dist
            </summary>
            <param name="name"></param>
            <param name="cancel"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.ValidateTagName(System.String)">
            <summary>
                perform a validation on a name
            </summary>
            <param name="tagName"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.CreateExtended(System.Collections.Generic.IEnumerable{honooru.Models.App.Tag})">
            <summary>
                create <see cref="T:honooru.Models.Api.ExtendedTag"/>s from <see cref="T:honooru.Models.App.Tag"/>s
            </summary>
            <param name="tags">list of <see cref="T:honooru.Models.App.Tag"/>s to convert into a list of <see cref="T:honooru.Models.Api.ExtendedTag"/>s</param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.Insert(honooru.Models.App.Tag)">
            <summary>
                insert a new <see cref="T:honooru.Models.App.Tag"/>
            </summary>
            <param name="tag"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.Update(honooru.Models.App.Tag)">
            <summary>
                update an existing <see cref="T:honooru.Models.App.Tag"/>
            </summary>
            <param name="tag"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagRepository.DamerauLevenshteinDistance(System.String,System.String,System.Int32)">
            <summary>
            Computes the Damerau-Levenshtein Distance between two strings, represented as arrays of
            integers, where each integer represents the code point of a character in the source string.
            Includes an optional threshhold which can be used to indicate the maximum allowable distance.
            </summary>
            <remarks>
                copied from https://stackoverflow.com/questions/9453731/how-to-calculate-distance-similarity-measure-of-given-2-strings/9454016#9454016 
            </remarks>
            <param name="source">An array of the code points of the first string</param>
            <param name="target">An array of the code points of the second string</param>
            <param name="threshold">Maximum allowable distance</param>
            <returns>Int.MaxValue if threshhold exceeded; otherwise the Damerau-Leveshteim distance between the strings</returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagTypeRepository.GetAll">
            <summary>
                get all <see cref="T:honooru.Models.App.TagType"/>s
            </summary>
            <returns>
                a list of <see cref="T:honooru.Models.App.TagType"/>s
            </returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagTypeRepository.GetByID(System.UInt64)">
            <summary>
                get the <see cref="T:honooru.Models.App.TagType"/> with <see cref="P:honooru.Models.App.TagType.ID"/> of <paramref name="typeID"/>
            </summary>
            <param name="typeID">ID of the <see cref="T:honooru.Models.App.TagType"/> to get</param>
            <returns>
                the <see cref="T:honooru.Models.App.TagType"/> with <see cref="P:honooru.Models.App.TagType.ID"/> of <paramref name="typeID"/>,
                or <c>null</c> if it does not exist
            </returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagTypeRepository.GetByIDs(System.Collections.Generic.IEnumerable{System.UInt64})">
            <summary>
                get a list of <see cref="T:honooru.Models.App.TagType"/>s based on <see cref="P:honooru.Models.App.TagType.ID"/>
            </summary>
            <param name="ids"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Repositories.TagTypeRepository.GetByNameOrAlias(System.String)">
            <summary>
                get a <see cref="T:honooru.Models.App.TagType"/> by its <see cref="P:honooru.Models.App.TagType.Name"/> or <see cref="P:honooru.Models.App.TagType.Alias"/>
            </summary>
            <param name="name">name or alias of the <see cref="T:honooru.Models.App.TagType"/> to get</param>
            <returns>
                the <see cref="T:honooru.Models.App.TagType"/> with either <see cref="P:honooru.Models.App.TagType.Name"/> or <see cref="P:honooru.Models.App.TagType.Alias"/>
                of <paramref name="name"/>, or <c>null</c> if it does not exist
            </returns>
        </member>
        <member name="M:honooru.Services.ServiceHealthMonitorExtensions.GetOrCreate(honooru.Services.ServiceHealthMonitor,System.String)">
            <summary>
                Get the <see cref="T:honooru.Models.ServiceHealthEntry"/> with <see cref="P:honooru.Models.ServiceHealthEntry.Name"/> of <paramref name="serviceName"/>,
                creating it if it does not exist
            </summary>
            <param name="monitor"></param>
            <param name="serviceName"></param>
            <returns></returns>
        </member>
        <member name="M:honooru.Services.Util.FileExtensionService.IsValid(System.String)">
            <summary>
                check if an extension is valid or not
            </summary>
            <param name="extension"></param>
            <returns></returns>
        </member>
    </members>
</doc>
